---
typora-copy-images-to: assert
typora-root-url: assert
---

[TOC]



# 一、商品业务

## 1.商品上架（ES+SpuInfo）

```properties
POST /product/spuinfo/{spuId}/up

接口功能解析：
	1.修改spu状态为已上架
	2.保存sku信息到es中，以skuId作为文档ID
		sku默认图片
		sku标题
		sku价格
		销量
		spu允许被检索的基本规格（尺寸、CPU、分辨率）
```

### 1.1.商品json文档格式分析

```json
------格式1：（商品索引保存sku+attr信息）【浪费空间节省时间】
{
    skuId:1
    spuId:11
    skuTitle:华为xx
    price:998
    attrs:[
    	{尺寸:5寸},
		{CPU:高通945},
		{分辨率:全高清}
    ]
}
优势：方便检索
劣势：造成attrs冗余
	假设属性2KB
	100万条SKU * 2KB = 1000,000 * 2KB = 2000MB = 2G
------------------------------------------------------
------格式2：（sku与attr分开保存）【节省空间浪费时间】
sku索引 {
    skuId:1
    spuId:11
    skuTitle:华为xx
    price:998
}

attr索引 {
    spuId:11
    attrs:[
    	{尺寸:5寸},
		{CPU:高通945},
		{分辨率:全高清}
    ]
}
优势：数据不冗余
劣势：网络带宽大
	例：查询小米，会搜到粮食、手机、电器，假设会查到10000个商品，包含4000个spu，因为要汇总所有商品的属性并列出，所以需要向后台传4000个spuId查询attr索引，spuId是Long类型，假设8byte，8byte*4000=32000byte=32Kb
如果此时1000,000人检索，数据传输达到32GB

------------------------------------------------------
结果：采用格式1
```

### 1.2.商品文档格式（nested、doc_values、analyzer）

```json
解析：
	"type": "text",// 全文检索字段
	"type": "keyword",// 非全文检索字段
    "index": false,// 不参与检索
    "doc_values": false// 不参与聚合统计（term）
	"analyzer": "ik_smart"// 使用ik分词器
```

文档格式：

```json
PUT product
{
  "mappings": {
    "properties": {
      "skuId": {
        "type": "long"
      },
      "spuId": {
        "type": "keyword"
      },
      "skuTitle": {
        "type": "text",
        "analyzer": "ik_smart"
      },
      "skuPrice": {
        "type": "keyword"
      },
      "skuImg": {
        "type": "keyword",
        "index": false,
        "doc_values": false
      },
      "saleCount": {
        "type": "long"
      },
      "hasStock": {
        "type": "boolean"
      },
      "hotScore": {
        "type": "long"
      },
      "brandId": {
        "type": "long"
      },
      "catalogId": {
        "type": "long"
      },
      "brandName": {
        "type": "keyword",
        "index": false,
        "doc_values": false
      },
      "brandImg": {
        "type": "keyword",
        "index": false,
        "doc_values": false
      },
      "catalogName": {
        "type": "keyword",
        "index": false,
        "doc_values": false
      },
      "attrs": {
        "type": "nested",
        "properties": {
          "attrId": {
            "type": "long"
          },
          "attrName": {
            "type": "keyword",
            "index": false,
            "doc_values": false
          },
          "attrValue": {
            "type": "keyword"
          }
        }
      }
    }
  }
}
```

### 1.3.nested数据类型分析

```json
简介：
	未加nested数据类型的数组类型数据保存时会被es扁平化处理，导致查询的时候回出现错误，查看下例未加nested数据类型导致扁平化的案例：
	
案例：（存储一条id=1的数据）
PUT my_index/_doc/1
{
    "group": "fans",
    "user": [
        {
            "first": "John",
            "last": "Smith"
        },{
            "first": "Alice",
            "last": "White"
        }
    ]
}

es会处理成：
{
    "group": "fans",
    "user.first": ["Alice", "John"],
    "user.last": ["Smith", "White"]
}

查询my_index索引映射
GET my_index/_mapping
{
  "my_index" : {
    "mappings" : {
      "properties" : {
        "group" : {
          "type" : "text",
          "fields" : {
            "keyword" : {
              "type" : "keyword",
              "ignore_above" : 256
            }
          }
        },
        "user" : {
          "properties" : {
            "first" : {
              "type" : "text",
              "fields" : {
                "keyword" : {
                  "type" : "keyword",
                  "ignore_above" : 256
                }
              }
            },
            "last" : {
              "type" : "text",
              "fields" : {
                "keyword" : {
                  "type" : "keyword",
                  "ignore_above" : 256
                }
              }
            }
          }
        }
      }
    }
  }
}

检索：（查询Alice+Smith也可以查到，实际应该是没有这条数据的）
GET my_index/_search
{
    "query": {
        "bool": {
            "must": [
                {"match": {"user.first": "Alice"}},
                {"match": {"user.last": "Smith"}}
            ]
        }
    }
}
```

#### 使用nested类型映射

```json
上面案例的正确映射方式：（避免了es自动对数据扁平化处理）
PUT my_index
{
    "mappings": {
        "properties": {
            "user": {
                "type": "nested"
            }
        }
    }
}

然后再存储数据，按照以上查询方式查询不会再查询到值
```

```json
基本规格案例：
"attrs": {
    "type": "nested",
    "properties": {
    "attrId": {
    	"type": "long"
    },
    "attrName": {
    	"type": "keyword",
        "index": false,
        "doc_values": false
    },
    "attrValue": {
    	"type": "keyword"
    }
}
```

### 1.4.商品上架接口

```java
POST /product/spuinfo/{spuId}/up
```

#### TO商品传输对象

```java
产品模块上架接口要调用es模块，所以在common模块新增TO对象

@Data
public class SkuEsModel {
    private Long skuId;
    private Long spuId;
    private String skuTitle;
    private BigDecimal skuPrice;
    private String skuImg;
    private Long saleCount;
    private Boolean hasStock;
    private Long hotScore;
    private Long brandId;
    private Long catalogId;
    private String brandName;
    private String brandImg;
    private String catalogName;
    private List<Attrs> attrs;

    // 存储为es数据时应该作为nested类型存储
    @Data
    public static class Attrs {
        private Long attrId;
        private String attrName;
        private String attrValue;
    }
}
```

#### Service上架代码

```java
/**
 * sup商品上架
 * 往es上架商品不会重复上架，因为上架时指定了skuId
 */
@Override
public void up(Long spuId) {
    // 1.查询spuId对应的所有sku信息
    List<SkuInfoEntity> skus = skuInfoService.getSkusBySpuId(spuId);

    // 2.封装待上传es数据集合（skuEsModel）
    // 查询spu关联的基本属性集合
    Map<Long, ProductAttrValueEntity> attrMap = productAttrValueService.baseAttrlistforspu(spuId)
        .stream().collect(Collectors.toMap(key -> key.getAttrId(), val -> val));
    // 查询允许被检索的基本属性集合ID
    List<Long> searAttrIds = attrService.selectSearchAttrIds(new ArrayList<>(attrMap.keySet()));
    // 查询允许被检索的基本属性属性集合，并封装成attrEsModels
    List<SkuEsModel.Attrs> attrEsModels = searAttrIds.stream().map(attrId -> {
        SkuEsModel.Attrs attrModel = new SkuEsModel.Attrs();
        ProductAttrValueEntity attrValue = attrMap.get(attrId);
        // 封装基本属性
        attrModel.setAttrId(attrValue.getAttrId());
        attrModel.setAttrName(attrValue.getAttrName());
        attrModel.setAttrValue(attrValue.getAttrValue());
        return attrModel;
    }).collect(Collectors.toList());

    Map<Long, Boolean> skuHasStockMap = null;
    try {
        // 查询库存
        List<Long> skuIds = skus.stream().map(SkuInfoEntity::getSkuId).collect(Collectors.toList());
        skuHasStockMap = wareAgentService.getSkusHasStock(skuIds).stream()
            .collect(Collectors.toMap(SkuHasStockTO::getSkuId, val -> val.getHasStock()));
    } catch (Exception e) {
        log.error("库存查询异常：原因{}", e);
    }
    Map<Long, Boolean> finalSkuHasStockMap = skuHasStockMap;
    List<SkuEsModel> upProducts = skus.stream().map(sku -> {
        // 3.遍历sku封装SkuEsModel
        SkuEsModel esModel = new SkuEsModel();
        // 封装属性名相同的属性值
        BeanUtils.copyProperties(sku, esModel);
        // 封装属性名不相同的属性值 skuPrice, skuImg
        esModel.setSkuPrice(sku.getPrice());
        esModel.setSkuImg(sku.getSkuDefaultImg());

        // 封装库存（远程调用失败，默认设置有库存）
        esModel.setHasStock(finalSkuHasStockMap == null ? true : finalSkuHasStockMap.get(sku.getSkuId()));

        // TODO 热度评分 hotScore（这里直接设置0，待扩展）
        esModel.setHotScore(0L);

        // 封装品牌和分类的名字
        BrandEntity brand = brandService.getById(sku.getBrandId());
        esModel.setBrandName(brand.getName());
        esModel.setBrandImg(brand.getLogo());
        CategoryEntity category = categoryService.getById(sku.getCatalogId());
        esModel.setCatalogName(category.getName());

        // 封装允许被检索的基本属性值（多条sku冗余）
        esModel.setAttrs(attrEsModels);
        return esModel;
    }).collect(Collectors.toList());

    // 4.调用es模块保存数据
    boolean result = searchAgentService.productStatusUp(upProducts);
    if (result) {
        // 上架成功
        // 5.修改sku商品状态，上架状态
        baseMapper.updateSpuStatus(spuId, SpuConstant.PublishStatusEnum.SPU_UP.getCode());
    } else {
        // 上架失败
        // TODO 7.重复调用，接口幂等性（重试机制）

    }
}
```

## 2、动静分离（Nginx）

```
简介：
	1.出于教学目的未采用前后端分离，使用视图
	2.静态资源放在nginx中（图片、js、css[视图所需的资源]）
	3.动态资源（需要服务器处理的请求）独立部署、运行、升级
	4.nginx接收用户请求转发至网关，网关作统一限流、鉴权，网关再转发给各模块
```

![1635252896627](1635252896627.png)

### 1.1.整合thymeleaf（模板引擎）

```java
thymeleaf官方文档，查看语法
    https://www.thymeleaf.org/documentation.html
可以下载pdf文档：using thymeleaf 

1.添加依赖
        <!--模板引擎thymeleaf-->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-thymeleaf</artifactId>
        </dependency>

2.关闭缓存【调试时可以实时查看效果】
spring:
  thymeleaf:
    cache: false
    suffix: .html		# 默认配置
    prefix: /templates/   # 默认配置

3.复制.html到templates文件夹内
  复制静态资源到static文件夹内
  
4.修改controller包名为app，表示rest请求
新建web包，表示请求跳转

5.增加mvc配置类，处理资源无法加载的问题
@Configuration
public class WebMvcConfig implements WebMvcConfigurer {

    /**
     * 添加处理器
     * 未加该处理器时使用此链接请求资源localhost:10000/index/js/swiper-3.4.2.jquery.min.js
     * 添加处理器后使用此链接请求资源localhost:10000/static/index/js/swiper-3.4.2.jquery.min.js
     */
    @Override
    public void addResourceHandlers(ResourceHandlerRegistry registry) {
        registry.addResourceHandler("/static/**").addResourceLocations("classpath:/static/");
    }
}

6.localhost:10000访问首页
springboot作了自动配置，WebMvcAutoConfiguration


7.controller包新增页面跳转controller，增加页面跳转请求
@Controller 
public class IndexController {
    @GetMapping({"/", "index.html"})
    public String indexPage(Model model) {
		// 查出所有1级分类
        List<CategoryEntity> categoryEntitys = categoryService.getLevel1Categorys();

        // 
        model.addAttribute("categorys", categoryEntitys);
        
        // 解析器自动拼装classpath:/templates/  + index +  .html =》 classpath:/templates/index.html
        // classpath表示类路径，编译前是resources文件夹，编译后resources文件夹内的文件会统一存放至classes文件夹内
        return "index";
    }
}
    
8.粘贴名称空间，才可以使用thymeleaf语法
<html lang="en" xmlns:th="http://www.thymeleaf.org">
    
    
10.实现不重启服务实时更新页面
	1）引入dev-tools
        <!--devtools实现不重启服务实时更新页面-->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-devtools</artifactId>
            <optional>true</optional>
        </dependency>
	2）引入后按 ctrl+shift+F9 【Recompile build project重新编译项目】
    	注意：需要关掉thymeleaf服务器缓存

```

 ![1635254117720](1635254117720.png)

 ![1635254296665](1635254296665.png)

 ![1635257488124](1635257488124.png)

### 1.2.渲染三级分类

```java
1.三级分类返回json格式
{
    "一级分类ID": [
        {
            "catalog1Id": "一级分类ID",
            "id": "二级分类ID",
            "name": "二级分类名",
            "catalog3List":[
                {
                    "catalog2Id": "二级分类ID",
                    "id": "三级分类ID",
                    "name": "三级分类名"
                }
            ]
        }
    ]
}

2.返回数据格式List<String, List<Catalog2VO>>
/**
 * 2级分类VO
 */
@NoArgsConstructor
@AllArgsConstructor
@Data
public class Catalog2VO {

    private String catalog1Id;  // 1级父分类ID
    private List<Catalog3Vo> catalog3List;// 3级子分类集合
    private String id;  // 2级分类ID
    private String name;  // 2级分类name

    /**
     * 三级分类Vo
     */
    @NoArgsConstructor
    @AllArgsConstructor
    @Data
    public static class Catalog3Vo {
        private String catalog2Id;  // 2级父分类ID
        private String id;  // 3级分类ID
        private String name;  // 3级分类name
    }
}

3.查询三级分类并封装成Map返回
@Override
public Map<String, List<Catalog2VO>> getCatalogJson() {
    // 1.查询1级分类
    List<CategoryEntity> level1Categorys = getLevel1Categorys();

    // 2.封装数据
    Map<String, List<Catalog2VO>> map = level1Categorys.stream().collect(Collectors.toMap(key -> key.getCatId().toString(), l1Category -> {
        // 3.查询2级分类，并封装成List<Catalog2VO>
        List<Catalog2VO> catalog2VOS = baseMapper.selectList(new QueryWrapper<CategoryEntity>().eq("parent_cid", l1Category.getCatId()))
                .stream().map(l2Category -> {
                    // 4.查询3级分类，并封装成List<Catalog3VO>
                    List<Catalog2VO.Catalog3Vo> catalog3Vos = baseMapper.selectList(new QueryWrapper<CategoryEntity>().eq("parent_cid", l2Category.getCatId()))
                            .stream().map(l3Category -> {
                                // 封装3级分类VO
                                Catalog2VO.Catalog3Vo catalog3Vo = new Catalog2VO.Catalog3Vo(l2Category.getCatId().toString(), l3Category.getCatId().toString(), l3Category.getName());
                                return catalog3Vo;
                            }).collect(Collectors.toList());
                    // 封装2级分类VO返回
                    Catalog2VO catalog2VO = new Catalog2VO(l1Category.getCatId().toString(), catalog3Vos, l2Category.getCatId().toString(), l2Category.getName());
                    return catalog2VO;
                }).collect(Collectors.toList());
        return catalog2VOS;
    }));

    return map;
}
```

#### 优化版三级分类

```java
/**
 * 查询三级分类并封装成Map返回
 */
@Override
public Map<String, List<Catalog2VO>> getCatalogJson() {
    // 1.查询所有分类，按照parentCid分组
    Map<Long, List<CategoryEntity>> categoryMap = baseMapper.selectList(null).stream()
            .collect(Collectors.groupingBy(key -> key.getParentCid()));

    // 2.获取1级分类
    List<CategoryEntity> level1Categorys = categoryMap.get(0L);

    // 3.封装数据
    Map<String, List<Catalog2VO>> map = level1Categorys.stream().collect(Collectors.toMap(key -> key.getCatId().toString(), l1Category -> {
        // 3.查询2级分类，并封装成List<Catalog2VO>
        List<Catalog2VO> catalog2VOS = categoryMap.get(l1Category.getCatId())
                .stream().map(l2Category -> {
                    // 4.查询3级分类，并封装成List<Catalog3VO>
                    List<Catalog2VO.Catalog3Vo> catalog3Vos = categoryMap.get(l2Category.getCatId())
                            .stream().map(l3Category -> {
                                // 封装3级分类VO
                                Catalog2VO.Catalog3Vo catalog3Vo = new Catalog2VO.Catalog3Vo(l2Category.getCatId().toString(), l3Category.getCatId().toString(), l3Category.getName());
                                return catalog3Vo;
                            }).collect(Collectors.toList());
                    // 封装2级分类VO返回
                    Catalog2VO catalog2VO = new Catalog2VO(l1Category.getCatId().toString(), catalog3Vos, l2Category.getCatId().toString(), l2Category.getName());
                    return catalog2VO;
                }).collect(Collectors.toList());
        return catalog2VOS;
    }));

    return map;
}
```



### 1.3.动静分离

![1635434764388](1635434764388.png)

```java
1.未动静分离，指的是静态资源全都存储在Tomcat中，所有静态资源都要从Tomcat获取，
会访问 nginx->gateway->Tomcat获取静态资源，从而导致占用Tomcat很多线程来处理静态资源

2.动静分离，表示将资源与web服务器分离，可存放在nginx中，静态资源直接从nginx中返回
/static/**所有请求都由nginx直接返回

步骤：
	1）cd /mydata/nginx/html
	mkdir static
	
	2）将product项目内static文件夹下的index文件夹，拖到/mydata/nginx/html/static此目录下
	
	3）修改index.html中静态资源的请求路径
	src="index/ =》 src="/static/index/
	href=" =》 href="/static/
	<script src=" => <script src="/static/
	<img src=" => <img src="/static/
	url('/  =>  


动静分离前下例请求会访问nginx=》gateway=》product=》static...
http://gulimall.com/index/img/img_09.png
分离后使用下例请求直接访问nginx中的静态资源
http://gulimall.com/static/index/img/img_09.png

	4）修改gulimall.conf配置（监听gulimall.com/static请求，使用root作为根路径查找静态资源）：
    location /static/ {
        root /usr/share/nginx/html;
    }
    
    解析：/static/index/img/img_09.png会找到挂载目录/usr/share/nginx/html
    /usr/share/nginx/html/static/index/img/img_09.png
```

 ![1635435409426](1635435409426.png)

 ![1635437211407](1635437211407.png)

```json
server {
    listen       80;
    server_name gulimall.com;

    location /static/ {
        root /usr/share/nginx/html;
    }

    location / {
        proxy_set_header Host $host;
        proxy_pass http://gulimall;
    }

    error_page   500 502 503 504  /50x.html;
    location = /50x.html {
        root   /usr/share/nginx/html;
    }
}
```





# 二、nginx搭建域名访问环境

## 1.正向代理与反向代理

```
1.正向代理：（重点：需要配置，互联网被请求资源无感知）
	例如无法访问google，配置代理服务器，将请求转发给代理服务器，然后代理服务器访问互联网内容并返回给客户端

2.反向代理：（重点：无需配置，客户端无感知）
	屏蔽内网服务器信息，负载均衡访问
	所有请求访问反向代理服务器
```

![1635340944791](1635340944791.png)

 ![1635341930403](1635341930403.png)

### 1.1.配置本地dns解析

```json
1.使用SwitchHosts设置本地ip 域名解析
https://sm.myapp.com/original/System/SwitchHosts_v0.2.2.1785.7z

# gulimall
192.168.56.10       gulimall.com
```



### 1.2.nginx作为反向代理

```sh
1.了解nginx配置文件，看下面的截图

2.一个nginx.conf会包含多个server快（conf.d内*.conf文件）

3.拷贝配置文件
cp default.conf gulimall.conf

注：1）vi时推出编辑模式，双击dd可以删除行
    2）:set number 显示vi文本的行号

详解server块：
root   /usr/share/nginx/html;// 表示去该路径下查询静态资源




server {
    listen       80;// 监听80端口
    server_name  gulimall.com;// 监听的请求host，如果是gulimall.com则接收请求

    location / {
    	proxy_pass http://192.168.56.1:10000;// 将请求转发给商品服务
    }

    error_page   500 502 503 504  /50x.html;
    location = /50x.html {
        root   /usr/share/nginx/html;
    }
}
```

![1635343402434](1635343402434.png)

### 1.3.nginx负载均衡配置

```properties
1.查看文档（Using nginx as HTTP load balancer）
https://nginx.org/en/docs/

在http块配置上游服务器，查看上节截图，nginx.conf总共分为多块，http块在nginx.conf文档中

http {
    upstream gulimall {// 上游服务器名
        server 192.168.56.1:88;// 负载均衡时配置多个网关地址
        server 192.168.56.1:89;
    }

    server {
        listen 80;
        server_name gulimall.com;

        location / {
            proxy_pass http://gulimall;// 代理给上游服务器
        }
    }
}
```

### 1.4.配置步骤

```json
1.在http块中配置上游服务器
nginx.conf：

http {
    
    upstream gulimall {
        server 192.168.56.1:88;
    }
}

2.配置server块，gulimall.conf
    server {
        listen 80;
        server_name gulimall.com;

        location / {
            proxy_pass http://gulimall;
        }
    }

3.配置网关断言规则
文档：
https://docs.spring.io/spring-cloud-gateway/docs/2.2.4.RELEASE/reference/html/
=》Route Predicate Factories=》The Host Route Predicate Factory

      - id: gulimall_product_route
        uri: lb://gulimall-product
        predicates:
        - Host=gulimall.com,item.gulimall.com

注意：此段配置要放在所有微服务路由后面，因为gulimall.com会拦截访问api请求：
gulimall.com/api/product/attr/list

4.nginx反向代理时会丢失host信息，配置server块，转发时同时转发hosts
    server {
        listen 80;
        server_name gulimall.com;

        location / {
        	proxy_set_header Host $host;
            proxy_pass gulimall;
        }
    }

5.访问以下链接测试是否成功
http://gulimall.com/ ：成功访问首页
http://gulimall.com/api/product/attr/list：成功访问api
```

![1635347014300](1635347014300.png)

#### bug静态资源无法访问

```java
@Configuration
public class WebMvcConfig implements WebMvcConfigurer {

    /**
     * 添加处理器
     * 将所有/static访问静态资源的请求映射到/static类路径下
     *
     * 使用该处理器的场景：
     *      templates拷贝的是自己之前改动过的gulimall项目，动静分离时静态资源访问路径前都添加了/static/导致了无法在现有项目的
     *      类路径下访问到静态资源，有3种解决方案
     *          1.创建以下目录结构 resources/static/static/index
     *          2.创建以下目录结构 resources/static/index，删除引用静态资源时的/static前缀
     *          3.创建以下目录结构 resources/static/index，增加以下处理器重定义加载静态资源的类路径classpath:/static/
     */
    @Override
    public void addResourceHandlers(ResourceHandlerRegistry registry) {
        registry.addResourceHandler("/static/**").addResourceLocations("classpath:/static/");
    }

}
```

## 2.最终模板（重点）

```shell
# nginx.conf
user  nginx;
worker_processes  1;

error_log  /var/log/nginx/error.log warn;
pid        /var/run/nginx.pid;


events {
    worker_connections  1024;
}

http {
    include       /etc/nginx/mime.types;
    default_type  application/octet-stream;

    log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
                      '$status $body_bytes_sent "$http_referer" '
                      '"$http_user_agent" "$http_x_forwarded_for"';

    access_log  /var/log/nginx/access.log  main;

    sendfile        on;
    #tcp_nopush     on;

    keepalive_timeout  65;

	# 上游服务器
    upstream gulimall {
        server 192.168.56.1:88;
    }

    #gzip  on;
    
    # 引入server块
    include /etc/nginx/conf.d/*.conf;
}
```

```shell
# gulimall.conf【server快】
server {
	# 监听80端口，监听域名*.gulimall.com、gulimall.com
    listen       80;
    server_name gulimall.com *.gulimall.com;
	
	# 静态资源请求访问/usr/share/nginx/html
    location /static/ {
        root /usr/share/nginx/html;
    }

	# 动态资源请求访问上游服务器
    location / {
        proxy_set_header Host $host;
        proxy_pass http://gulimall;
    }

    error_page   500 502 503 504  /50x.html;
    location = /50x.html {
        root   /usr/share/nginx/html;
    }
}
```



# 三、缓存

## 1.获取三级分类加入缓存

### **DB查询+缓存同步方法**

```java
/**
 * 查询三级分类（从数据源DB查询）
 * 加入分布式锁版本代码，double check检查
 */
public Map<String, List<Catalog2VO>> getCatalogJsonFromDB() {
    // 1.double check，占锁成功需要再次检查缓存
    // 查询非空即返回
    String catlogJSON = redisTemplate.opsForValue().get("catlogJSON");
    if (!StringUtils.isEmpty(catlogJSON)) {
        // 查询成功直接返回不需要查询DB
        Map<String, List<Catalog2VO>> result = JSON.parseObject(catlogJSON, new TypeReference<Map<String, List<Catalog2VO>>>() {
        });
        return result;
    }

    // 2.查询所有分类，按照parentCid分组
    Map<Long, List<CategoryEntity>> categoryMap = baseMapper.selectList(null).stream()
            .collect(Collectors.groupingBy(key -> key.getParentCid()));

    // 3.获取1级分类
    List<CategoryEntity> level1Categorys = categoryMap.get(0L);

    // 4.封装数据
    Map<String, List<Catalog2VO>> result = level1Categorys.stream().collect(Collectors.toMap(key -> key.getCatId().toString(), l1Category -> {
        // 3.查询2级分类，并封装成List<Catalog2VO>
        List<Catalog2VO> catalog2VOS = categoryMap.get(l1Category.getCatId())
                .stream().map(l2Category -> {
                    // 4.查询3级分类，并封装成List<Catalog3VO>
                    List<Catalog2VO.Catalog3Vo> catalog3Vos = categoryMap.get(l2Category.getCatId())
                            .stream().map(l3Category -> {
                                // 封装3级分类VO
                                Catalog2VO.Catalog3Vo catalog3Vo = new Catalog2VO.Catalog3Vo(l2Category.getCatId().toString(), l3Category.getCatId().toString(), l3Category.getName());
                                return catalog3Vo;
                            }).collect(Collectors.toList());
                    // 封装2级分类VO返回
                    Catalog2VO catalog2VO = new Catalog2VO(l1Category.getCatId().toString(), catalog3Vos, l2Category.getCatId().toString(), l2Category.getName());
                    return catalog2VO;
                }).collect(Collectors.toList());
        return catalog2VOS;
    }));

    // 5.结果集存入redis
    // 关注锁时序问题，存入redis代码块必须在同步快内执行
    redisTemplate.opsForValue().set(CategoryConstant.CACHE_KEY_CATALOG_JSON,
            JSONObject.toJSONString(result), 1, TimeUnit.DAYS);

    return result;
}
```

### 1.1.无锁版本

```java
/**
 * 搭配缓存查询三级分类
 */
@Override
public Map<String, List<Catalog2VO>> getCatalogJson() {
    // 查询缓存
    String catalogJSON = redisTemplate.opsForValue().get(CategoryConstant.CACHE_KEY_CATALOG_JSON);

    if (StringUtils.isEmpty(catalogJSON)) {
        // 未命中缓存
        // 查询db
        Map<String, List<Catalog2VO>> result = getCatalogJsonFromDB();
        redisTemplate.opsForValue().set(CategoryConstant.CACHE_KEY_CATALOG_JSON,
                JSONObject.toJSONString(result), 1, TimeUnit.DAYS);
        return result;
    }

    // 命中缓存
    Map<String, List<Catalog2VO>> result = JSONObject.parseObject(catalogJSON, new TypeReference<Map<String, List<Catalog2VO>>>() {
    });

    return result;
}
```

### 1.2.本地锁版本

```java
/**
 * 查询三级分类（本地锁版本）
 * 已废弃
 */
@Deprecated
public Map<String, List<Catalog2VO>> getCatalogJsonFromDBWithLocalLock() {
    // 本地锁：synchronized，JUC(lock)，在分布式0情况下，需要使用分布式锁
    synchronized (this) {
        // 得到锁以后还要检查一次，double check
        return getCatalogJsonFromDB();
    }
}
```

### 1.3.redisTemplate锁版本

```java
/**
 * 查询三级分类（原生版redis分布式锁版本）
 */
public Map<String, List<Catalog2VO>> getCatalogJsonFromDBWithRedisLock() {
    // 1.抢占分布式锁，同时设置过期时间
    String uuid = UUID.randomUUID().toString();
    // 使用setnx占锁（setIfAbsent）
    Boolean isLock = redisTemplate.opsForValue().setIfAbsent(CategoryConstant.LOCK_KEY_CATALOG_JSON, uuid, 300, TimeUnit.SECONDS);
    if (isLock) {
        // 2.抢占成功
        Map<String, List<Catalog2VO>> result = null;
        try {
            // 查询DB
            // TODO 业务续期（锁过期）【不应该添加业务续期代码】
            return getCatalogJsonFromDB();
        } finally {
            // 3.查询UUID是否是自己，是自己的lock就删除
            // 封装lua脚本（原子操作解锁）
            // 查询+删除（当前值与目标值是否相等，相等执行删除，不等返回0）
            String luaScript = "if redis.call('get',KEYS[1]) == ARGV[1]\n" +
                    "then\n" +
                    "    return redis.call('del',KEYS[1])\n" +
                    "else\n" +
                    "    return 0\n" +
                    "end";
            // 删除锁
            redisTemplate.execute(new DefaultRedisScript<Long>(luaScript, Long.class), Arrays.asList(CategoryConstant.LOCK_KEY_CATALOG_JSON), uuid);
        }
    } else {
        // 4.加锁失败，自旋重试
        // TODO 不应该使用递归，使用while，且固定次数
        try {
            Thread.sleep(200);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        return getCatalogJsonFromDBWithRedisLock();
    }
}
```

### 1.4.redisson锁版本（解决击穿+雪崩+穿透null值）

```java
/**
 * 查询三级分类（redisson分布式锁版本）
 */
public Map<String, List<Catalog2VO>> getCatalogJsonFromDBWithRedissonLock() {
    // 1.抢占分布式锁，同时设置过期时间
    RLock lock = redisson.getLock(CategoryConstant.LOCK_KEY_CATALOG_JSON);
    lock.lock(30, TimeUnit.SECONDS);
    try {
        // 2.查询DB
        Map<String, List<Catalog2VO>> result = getCatalogJsonFromDB();
        return result;
    } finally {
        // 3.释放锁
        lock.unlock();
    }
}
```

## 2.数据一致性问题

```java
1.修改三级分类 与 查询三级分类存在数据一致性问题（缓存与DB数据一致）

三种方案：
	1.仅加过期时间即可（首先考虑业务造成脏数据的概率，例如用户维度数据（订单数据、用户数据）并发几率很小，每过一段时间触发读的主动更新）
	2.canal订阅binlog的方式（菜单、商品介绍等基础数据）【完美解决】
	3.加读写锁
	4.实时性、一致性要求高的数据，应该直接查数据库
    
最终方案：
    1.所有数据加上过期时间
    2.读写数据加分布式读写锁（经常写的数据不要放在缓存里）
```

## 3.SpringCache

```java
注：
    1.springcache使用本地锁【只有@Cacheable可以同步】
    2.springcache可以解决击穿、雪崩、穿透【采用了本地锁，不是完全解决击穿，可以自己使用分布式锁（没必要）】
    3.springcache未解决数据一致性问题
```

### 3.1.失效模式+解决击穿、雪崩、穿透（分布式锁）

```java
/**
 * 级联更新所有关联表的冗余数据
 * 缓存策略：失效模式，方法执行完删除缓存
 */
@CacheEvict(value = {"category"}, allEntries = true)
@Transactional
@Override
public void updateCascade(CategoryEntity category) {
    this.updateById(category);
    if (!StringUtils.isEmpty(category.getName())) {
        // 更新冗余表
        categoryBrandRelationService.updateCategory(category.getCatId(), category.getName());
        // TODO 更新其他冗余表
    }
}

/**
 * 查出所有1级分类
 */
@Cacheable(value = {"category"}, key = "'getLevel1Categorys'")
@Override
public List<CategoryEntity> getLevel1Categorys() {
    System.out.println("调用了getLevel1Categorys...");
    // 查询父id=0
    return baseMapper.selectList(new QueryWrapper<CategoryEntity>().eq("parent_cid", 0));
}

/**
 * 查询三级分类并封装成Map返回
 * 使用SpringCache注解方式简化缓存设置
 */
@Cacheable(value = {"category"}, key = "'getCatalogJson'")
@Override
public Map<String, List<Catalog2VO>> getCatalogJsonWithSpringCache() {
    // 未命中缓存
    // 1.抢占分布式锁，同时设置过期时间【不使用读写锁，因为就是为了防止缓存击穿】
    RLock lock = redisson.getLock(CategoryConstant.LOCK_KEY_CATALOG_JSON);
    lock.lock(30, TimeUnit.SECONDS);
    try {
        // 2.double check，占锁成功需要再次检查缓存
        // 查询非空即返回
        String catlogJSON = redisTemplate.opsForValue().get("getCatalogJson");
        if (!StringUtils.isEmpty(catlogJSON)) {
            // 查询成功直接返回不需要查询DB
            Map<String, List<Catalog2VO>> result = JSON.parseObject(catlogJSON, new TypeReference<Map<String, List<Catalog2VO>>>() {
            });
            return result;
        }

        // 3.查询所有分类，按照parentCid分组
        Map<Long, List<CategoryEntity>> categoryMap = baseMapper.selectList(null).stream()
                .collect(Collectors.groupingBy(key -> key.getParentCid()));

        // 4.获取1级分类
        List<CategoryEntity> level1Categorys = categoryMap.get(0L);

        // 5.封装数据
        Map<String, List<Catalog2VO>> result = level1Categorys.stream().collect(Collectors.toMap(key -> key.getCatId().toString(), l1Category -> {
            // 6.查询2级分类，并封装成List<Catalog2VO>
            List<Catalog2VO> catalog2VOS = categoryMap.get(l1Category.getCatId())
                    .stream().map(l2Category -> {
                        // 7.查询3级分类，并封装成List<Catalog3VO>
                        List<Catalog2VO.Catalog3Vo> catalog3Vos = categoryMap.get(l2Category.getCatId())
                                .stream().map(l3Category -> {
                                    // 封装3级分类VO
                                    Catalog2VO.Catalog3Vo catalog3Vo = new Catalog2VO.Catalog3Vo(l2Category.getCatId().toString(), l3Category.getCatId().toString(), l3Category.getName());
                                    return catalog3Vo;
                                }).collect(Collectors.toList());
                        // 封装2级分类VO返回
                        Catalog2VO catalog2VO = new Catalog2VO(l1Category.getCatId().toString(), catalog3Vos, l2Category.getCatId().toString(), l2Category.getName());
                        return catalog2VO;
                    }).collect(Collectors.toList());
            return catalog2VOS;
        }));
        return result;
    } finally {
        // 8.释放锁
        lock.unlock();
    }
}
```

### 3.2.失效模式+解决击穿、雪崩、穿透（本地锁）

```java
/**
 * 级联更新所有关联表的冗余数据
 * 缓存策略：失效模式，方法执行完删除缓存
 */
@CacheEvict(value = {"category"}, allEntries = true)
@Transactional
@Override
public void updateCascade(CategoryEntity category) {
    this.updateById(category);
    if (!StringUtils.isEmpty(category.getName())) {
        // 更新冗余表
        categoryBrandRelationService.updateCategory(category.getCatId(), category.getName());
        // TODO 更新其他冗余表
    }
}

/**
 * 查出所有1级分类
 */
@Cacheable(value = {"category"}, key = "'getLevel1Categorys'", sync = true)
@Override
public List<CategoryEntity> getLevel1Categorys() {
    System.out.println("调用了getLevel1Categorys...");
    // 查询父id=0
    return baseMapper.selectList(new QueryWrapper<CategoryEntity>().eq("parent_cid", 0));
}

/**
 * 查询三级分类并封装成Map返回
 * 使用SpringCache注解方式简化缓存设置
 */
@Cacheable(value = {"category"}, key = "'getCatalogJson'", sync = true)
@Override
public Map<String, List<Catalog2VO>> getCatalogJsonWithSpringCache() {
    // 未命中缓存
    // 1.double check，占锁成功需要再次检查缓存（springcache使用本地锁）
    // 查询非空即返回
    String catlogJSON = redisTemplate.opsForValue().get("getCatalogJson");
    if (!StringUtils.isEmpty(catlogJSON)) {
        // 查询成功直接返回不需要查询DB
        Map<String, List<Catalog2VO>> result = JSON.parseObject(catlogJSON, new TypeReference<Map<String, List<Catalog2VO>>>() {
        });
        return result;
    }

    // 2.查询所有分类，按照parentCid分组
    Map<Long, List<CategoryEntity>> categoryMap = baseMapper.selectList(null).stream()
            .collect(Collectors.groupingBy(key -> key.getParentCid()));

    // 3.获取1级分类
    List<CategoryEntity> level1Categorys = categoryMap.get(0L);

    // 4.封装数据
    Map<String, List<Catalog2VO>> result = level1Categorys.stream().collect(Collectors.toMap(key -> key.getCatId().toString(), l1Category -> {
        // 5.查询2级分类，并封装成List<Catalog2VO>
        List<Catalog2VO> catalog2VOS = categoryMap.get(l1Category.getCatId())
                .stream().map(l2Category -> {
                    // 7.查询3级分类，并封装成List<Catalog3VO>
                    List<Catalog2VO.Catalog3Vo> catalog3Vos = categoryMap.get(l2Category.getCatId())
                            .stream().map(l3Category -> {
                                // 封装3级分类VO
                                Catalog2VO.Catalog3Vo catalog3Vo = new Catalog2VO.Catalog3Vo(l2Category.getCatId().toString(), l3Category.getCatId().toString(), l3Category.getName());
                                return catalog3Vo;
                            }).collect(Collectors.toList());
                    // 封装2级分类VO返回
                    Catalog2VO catalog2VO = new Catalog2VO(l1Category.getCatId().toString(), catalog3Vos, l2Category.getCatId().toString(), l2Category.getName());
                    return catalog2VO;
                }).collect(Collectors.toList());
        return catalog2VOS;
    }));
    return result;
}
```

# 四、检索服务

## 1.整合静态资源+页面模板

```properties
1.检索模块导入依赖
<!--模板引擎thymeleaf-->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-thymeleaf</artifactId>
</dependency>
<!--devtools热启动，实现不重启服务实时更新页面-->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-devtools</artifactId>
    <optional>true</optional>
</dependency>

2.拷贝list.html到检索模块resources.templates下
拷贝名称空间
<!DOCTYPE html>
<html lang="en" xmlns:th="http://www.thymeleaf.org">

3.关闭缓存，按ctrl+shift+F9实时更新页面
spring.thymeleaf.cache=false

4.创建以下文件路径
/mydata/nginx/html/static/search
实际映射到nginx容器的/static/search/路径

5.修改list.html静态资源引用路径为：
/static/search/
例：<link rel="stylesheet" href="/static/search/css/index.css">

6.将静态资源保存到/mydata/nginx/html/static/search路径下

7.添加本地域名解析
# gulimall
192.168.56.10 gulimall.com
192.168.56.10 search.gulimall.com

8.配置nginx拦截search.gulimall.com请求转发给88网关
配置gulimall.conf文件，使用*.gulimall.com拦截
server {
    listen       80;
    server_name  gulimall.com *.gulimall.com;

    location /static {
        root   /usr/share/nginx/html; # *.gulimall.com/static 请求nginx下静态资源
    }

    location / {
		proxy_set_header Host $host; # 反向代理封装请求头host
		proxy_pass http://gulimall; # 反向代理请求上游服务器（网关）
    }

    error_page   500 502 503 504  /50x.html;
    location = /50x.html {
        root   /usr/share/nginx/html;
    }

}

9.网关配置
- id: gulimall_product_route
  uri: lb://gulimall-product
  predicates:
  - Host=gulimall.com,item.gulimall.com

- id: gulimall_search_route
  uri: lb://gulimall-search
  predicates:
  - Host=search.gulimall.com
```

## 2.跳转检索页的三种情况

```json
首先编写controller接收请求
@Controller
public class SearchController {
    @GetMapping("/list.html")
    public String listPage() {
        return "list";
    }
}

三种情况：
1.点击三级分类跳转检索页list.html
	url：search.gulimall.com/list.html?catalog3Id=225

2.在首页输入框点击搜索跳转检索页list.html
前端监听事件onclick=search()
<a href="javascript:search()" ><img src="/static/index/img/img_09.png" onclick="search()" /></a>

3.点击筛选条件搜索
```

情况1：查询分类

 ![1636469356700](1636469356700.png)

情况2：查询关键字

![1636469365057](1636469365057.png)

情况3：筛选条件搜索

![1636469386501](1636469386501.png)

## 3.数据迁移（_reindex）

```json
简介：
	老的数据映射，设置了brandName不参与检索、不参与聚合，不符合接下来的业务需求，所以在不删除es数据的情况下需要做数据迁移
	
1.创建新索引
PUT gulimall_product
{
  "mappings": {
    "properties": {
      "skuId": {
        "type": "long"
      },
      "spuId": {
        "type": "keyword"
      },
      "skuTitle": {
        "type": "text",
        "analyzer": "ik_smart"
      },
      "skuPrice": {
        "type": "keyword"
      },
      "skuImg": {
        "type": "keyword"
      },
      "saleCount": {
        "type": "long"
      },
      "hasStock": {
        "type": "boolean"
      },
      "hotScore": {
        "type": "long"
      },
      "brandId": {
        "type": "long"
      },
      "catalogId": {
        "type": "long"
      },
      "brandName": {
        "type": "keyword"
      },
      "brandImg": {
        "type": "keyword"
      },
      "catalogName": {
        "type": "keyword"
      },
      "attrs": {
        "type": "nested",
        "properties": {
          "attrId": {
            "type": "long"
          },
          "attrName": {
            "type": "keyword"
          },
          "attrValue": {
            "type": "keyword"
          }
        }
      }
    }
  }
}

2.迁移数据
POST _reindex
{
    "source": {
        "index": "product"
    },
    "dest": {
        "index": "gulimall_product"
    }
}
```

## 4.编写检索接口

```java
1.检索接口
@Autowired
MallSearchService mallSearchService;

@GetMapping("/list.html")
public String listPage(SearchParam param, Model model, HttpServletRequest request) {

    param.set_queryString(request.getQueryString());
    SearchResult result = mallSearchService.search(param);
    model.addAttribute("result", result);
    return "list";
}

2.vo参数类（SearchParam）
/**
 * 封装页面所有可能传递过来的查询条件
 * 三种点击搜索的方式
 * 1、点击搜索：keyword   【skuTitle】
 * 2、点击分类：传catalog3Id【catalogld】
 * 3、选择筛选条件
 *      1、全文检索: keyword【skuTitle】
 *      2、排序: saleCount【销量】、hotScore【综合排序：热度评分】、skuPrice【价格】
 *      3、过滤: hasStock、skuPrice区间、brandld、catalog3ld、attrs
 *      4、聚合: attrs
 *          attrs=2_5寸 传参格式，所以直接for循环split("_")就可以得到attrId与attrValue
 *          attrs=1_白色:蓝色       然后值split(":")得到各项值attrValue
 */
@Data
public class SearchParam {

    private String keyword;// 页面传递过来的全文匹配关键字
    private Long catalog3Id;// 三级分类的id
    /**
     * 排序：sort=saleCount_asc  sort=hotScore_asc  sort=skuPrice_asc
     */
    private String sort;
    /**
     * 过滤条件：
     * hasStock=0/1【有货】
     * skuPrice=0_500/500_/_500【价格区间】
     * brandld=1
     * attrs=1_白色:蓝色&attrs=2_2寸:5寸【属性可多选，值也可多选】
     */
    private Integer hasStock;// 是否只显示有货，默认显示所有，null == 1会NullPoint异常  0/1
    private String skuPrice;// 是否只显示有货
    private List<Long> brandId;// 品牌id，可多选
    private List<String> attrs;// 三级分类的id
    private Integer pageNum = 1;// 页码

    private String _queryString;// 原生的所有查询条件
}
```

### 4.1.构建检索DSL语句分析

```json
1.全文检索查询都放在must里
skuTitle

2.不参与评分的放在filter里（比全文检索快）
catalogId、brandId

3.嵌入式字段的 查询、过滤、聚合 都要使用嵌入式的方式
```

```json
GET gulimall_product/_search
{
  "query": {
    "bool": {
      "must": [
        {
          "match": {
            "skuTitle": "手机"
          }
        }
      ],
      "filter": [
        {
          "term": {
            "catalogId": "225"
          }
        },
        {
          "terms": {
            "brandId": [
              "3",
              "5"
            ]
          }
        },
        {
          "nested": {
            "path": "attrs",
            "query": {
              "bool": {
                "must": [
                  {
                    "term": {
                      "attrs.attrId": {
                        "value": "6"
                      }
                    }
                  },
                  {
                    "terms": {
                      "attrs.attrValue": [
                        "海思(Hisilicon)",
                        "以官网信息为准"
                      ]
                    }
                  }
                ]
              }
            }
          }
        },
        {
          "term": {
            "hasStock": {
              "value": "true"
            }
          }
        },
        {
          "range": {
            "skuPrice": {
              "gte": 0,
              "lte": 7000
            }
          }
        }
      ]
    }
  },
  "sort": [
    {
      "skuPrice": {
        "order": "desc"
      }
    }
  ],
  "from": 0,
  "size": 2,
  "highlight": {
    "fields": {
      "skuTitle": {}
    },
    "pre_tags": "<b style='color:red'>",
    "post_tags": "</b>"
  },
  "aggs": {
    "brand_agg": {
      "terms": {
        "field": "brandId",
        "size": 10
      },
      "aggs": {
        "brand_name_agg": {
          "terms": {
            "field": "brandName",
            "size": 10
          }
        },
        "brand_img_agg":{
          "terms": {
            "field": "brandImg",
            "size": 10
          }
        }
      }
    },
    "catalog_agg": {
      "terms": {
        "field": "catalogId",
        "size": 10
      },
      "aggs": {
        "catalog_name_agg": {
          "terms": {
            "field": "catalogName",
            "size": 10
          }
        }
      }
    },
    "attr_agg":{
      "nested": {
        "path": "attrs"
      },
      "aggs": {
        "attr_id_agg": {
          "terms": {
            "field": "attrs.attrId",
            "size": 10
          },
          "aggs": {
            "attr_name_agg": {
              "terms": {
                "field": "attrs.attrName",
                "size": 10
              }
            },
            "attr_value_agg": {
              "terms": {
                "field": "attrs.attrValue",
                "size": 10
              }
            }
          }
        }
      }
    }
  }
}
```

### 4.2.构建检索对象SearchRequest

```java
/**
 * 动态构建检索请求
 * 模糊匹配，过滤（按照属性，分类，品牌，价格区间，库存），排序，分页，高亮 ,聚合分析【分析所有可选的规格、分类、品牌】
 */
private SearchRequest buildSearchRequest(SearchParam param) {
    // 构建SourceBuilder【通过builder构建DSL语句】
    SearchSourceBuilder builder = new SearchSourceBuilder();

    // 动态构建查询DSL语句【参照dsl.json分析包装步骤】
    // 查询：模糊匹配，过滤（按照属性，分类，品牌，价格区间，库存）
    // 1.构建bool
    BoolQueryBuilder boolQueryBuilder = QueryBuilders.boolQuery();
    // 1.1.构建must（模糊查询）
    if (StringUtils.isNotBlank(param.getKeyword())) {
        boolQueryBuilder.must(QueryBuilders.matchQuery("skuTitle", param.getKeyword()));
    }
    // 1.2.构建filter（过滤）
    // 1.2.1.三级分类
    if (param.getCatalog3Id() != null) {
        boolQueryBuilder.filter(QueryBuilders.termQuery("catalogId", param.getCatalog3Id()));
    }
    // 1.2.2.品牌id
    if (!CollectionUtils.isEmpty(param.getBrandId())) {
        boolQueryBuilder.filter(QueryBuilders.termsQuery("brandId", param.getBrandId()));
    }
    // 1.2.3.属性
    if (!CollectionUtils.isEmpty(param.getAttrs())) {
        for (String attr : param.getAttrs()) {
            // attrs=1_白色:蓝色
            String[] attrs = attr.split("_");
            String attrId = attrs[0];// 1
            String[] attrValues = attrs[1].split(":");// ["白色","蓝色"]
            BoolQueryBuilder nestedBoolQueryBuilder = QueryBuilders.boolQuery()
                    .must(QueryBuilders.termQuery("attrs.attrId", attrId))
                    .must(QueryBuilders.termsQuery("attrs.attrValue", attrValues));
            // 遍历每一个属性生成一个NestedQuery
            NestedQueryBuilder nestedQueryBuilder = QueryBuilders.nestedQuery("attrs", nestedBoolQueryBuilder, ScoreMode.None);// ScoreMode.None：不参与评分
            boolQueryBuilder.filter(nestedQueryBuilder);
        }
    }

    // 1.2.4.库存
    boolQueryBuilder.filter(QueryBuilders.termQuery("hasStock", param.getHasStock() == 1));

    // 1.2.5.价格区间【多种区间传参方式：1_500/_500/500_】
    if (StringUtils.isNotBlank(param.getSkuPrice())) {
        String[] prices = param.getSkuPrice().split("_");
        if (prices.length == 2) {
            // 1_500
            boolQueryBuilder.filter(QueryBuilders.rangeQuery("skuPrice").gte(prices[0]).lte(prices[1]));
        } else if (prices.length == 1) {
            if (param.getSkuPrice().startsWith("_")) {
                // _500
                boolQueryBuilder.filter(QueryBuilders.rangeQuery("skuPrice").lte(prices[0]));
            } else if (param.getSkuPrice().endsWith("_")) {
                // 500_
                boolQueryBuilder.filter(QueryBuilders.rangeQuery("skuPrice").gte(prices[0]));
            }
        }
    }

    // 1.3.封装bool【bool封装了模糊查询+过滤】
    builder.query(boolQueryBuilder);

    // 1.4.排序，分页，高亮
    // 1.4.1.排序
    if (StringUtils.isNotBlank(param.getSort())) {
        String[] sorts = param.getSort().split("_");
        builder.sort(sorts[0], sorts[1].toLowerCase().equals(SortOrder.ASC.toString()) ? SortOrder.ASC : SortOrder.DESC);
    }
    // 1.4.2.分页
    builder.from(EsConstant.PRODUCT_PAGESIZE * (param.getPageNum() - 1));
    builder.size(EsConstant.PRODUCT_PAGESIZE);
    // 1.4.3.高亮
    if (StringUtils.isNotBlank(param.getKeyword())) {
        // 模糊匹配才需要高亮
        HighlightBuilder highlightBuilder = new HighlightBuilder();
        highlightBuilder.field("skuTitle").preTags("<b style='color:red'>").postTags("</b>");
        builder.highlighter(highlightBuilder);
    }

    // 1.5.聚合分析【分析所有可选的规格、分类、品牌】
    // 1.5.1.品牌聚合
    TermsAggregationBuilder brandAgg = AggregationBuilders.terms("brand_agg").field("brandId").size(50);
    // 品牌聚合子聚合
    brandAgg.subAggregation(AggregationBuilders.terms("brand_name_agg").field("brandName").size(1));
    brandAgg.subAggregation(AggregationBuilders.terms("brand_img_agg").field("brandImg").size(1));
    builder.aggregation(brandAgg);

    // 1.5.2.分类聚合
    TermsAggregationBuilder catalogAgg = AggregationBuilders.terms("catalog_agg").field("catalogId").size(20);
    catalogAgg.subAggregation(AggregationBuilders.terms("catalog_name_agg").field("catalogName").size(1));
    builder.aggregation(catalogAgg);

    // 1.5.3.属性嵌套聚合
    NestedAggregationBuilder attrNestedAgg = AggregationBuilders.nested("attr_agg", "attrs");
    // 属性子聚合
    TermsAggregationBuilder attrIdAgg = AggregationBuilders.terms("attr_id_agg").field("attrs.attrId").size(50);
    attrNestedAgg.subAggregation(attrIdAgg);
    attrIdAgg.subAggregation(AggregationBuilders.terms("attr_name_agg").field("attrs.attrName").size(1));
    attrIdAgg.subAggregation(AggregationBuilders.terms("attr_value_agg").field("attrs.attrValue").size(50));
    builder.aggregation(attrNestedAgg);

    System.out.println("构建的DSL语句: " + builder.toString());
    // 根据构建了DSL语句的builder创建检索请求对象
    SearchRequest searchRequest = new SearchRequest(new String[]{EsConstant.PRODUCT_INDEX}, builder);
    return searchRequest;
}
```

### 4.3.封装返回结果SearchResponse

```java
/**
 * 封装检索结果
 * 1、返回所有查询到的商品
 * 2、分页信息
 * 3、当前所有商品涉及到的所有属性信息
 * 4、当前所有商品涉及到的所有品牌信息
 * 5、当前所有商品涉及到的所有分类信息
 */
private SearchResult buildSearchResuult(SearchResponse response, SearchParam param) {
    SearchResult result = new SearchResult();
    // ==========从命中结果获取===========hits
    SearchHits hits = response.getHits();// 获取命中结果
    // 1.返回所有查询到的商品
    List<SkuEsModel> products = new ArrayList<>();
    if (!ArrayUtils.isEmpty(hits.getHits())) {
        for (SearchHit hit : hits.getHits()) {
            String jsonString = hit.getSourceAsString();// 获取jsonString
            SkuEsModel esModel = JSONObject.parseObject(jsonString, SkuEsModel.class);
            if (StringUtils.isNotBlank(param.getKeyword())) {
                // 关键字不为空，返回结果包含高亮信息
                // 高亮信息
                String skuTitle = hit.getHighlightFields().get("skuTitle").fragments()[0].string();
                esModel.setSkuTitle(skuTitle);
            }
            products.add(esModel);
        }
    }
    result.setProducts(products);
    // 2.分页信息
    long total = hits.getTotalHits().value;
    long totalPages = total % EsConstant.PRODUCT_PAGESIZE == 0 ? total / EsConstant.PRODUCT_PAGESIZE : total / EsConstant.PRODUCT_PAGESIZE + 1;
    result.setPageNum(param.getPageNum());// 当前页码
    result.setTotal(total);// 总记录数
    result.setTotalPages((int) totalPages);// 总页码
    // 导航页码
    List<Integer> pageNavs = new ArrayList<>();
    for (int i = 1; i <= totalPages; i++) {
        pageNavs.add(i);
    }
    result.setPageNavs(pageNavs);
    
    // ==========从聚合结果获取===========aggregations
    Aggregations aggregations = response.getAggregations();// 获取聚合结果
    // 3.当前所有商品涉及到的所有属性信息
    ArrayList<SearchResult.AttrVo> attrs = new ArrayList<>();
    ParsedNested attrAgg = aggregations.get("attr_agg");
    ParsedLongTerms attrIdAgg = attrAgg.getAggregations().get("attr_id_agg");
    for (Terms.Bucket bucket : attrIdAgg.getBuckets()) {
        // 封装属性ID
        SearchResult.AttrVo attr = new SearchResult.AttrVo();
        attr.setAttrId(bucket.getKeyAsNumber().longValue());
        // 封装属性名
        ParsedStringTerms attrNameAgg = bucket.getAggregations().get("attr_name_agg");
        attr.setAttrName(attrNameAgg.getBuckets().get(0).getKeyAsString());
        // 封装属性值
        ParsedStringTerms attrValueAgg = bucket.getAggregations().get("attr_value_agg");
        List<String> attrValue = attrValueAgg.getBuckets().stream()
                .map(valueBucket -> valueBucket.getKeyAsString())
                .collect(Collectors.toList());
        attr.setAttrValue(attrValue);
        attrs.add(attr);
    }
    result.setAttrs(attrs);

    // 4.当前所有商品涉及到的所有品牌信息
    List<SearchResult.BrandVo> brands = new ArrayList<>();
    ParsedLongTerms brandAgg = aggregations.get("brand_agg");
    for (Terms.Bucket bucket : brandAgg.getBuckets()) {
        // 封装品牌ID
        SearchResult.BrandVo brand = new SearchResult.BrandVo();
        brand.setBrandId(bucket.getKeyAsNumber().longValue());
        // 封装品牌名
        ParsedStringTerms brandNameAgg = bucket.getAggregations().get("brand_name_agg");
        brand.setBrandName(brandNameAgg.getBuckets().get(0).getKeyAsString());
        // 封装品牌图片
        ParsedStringTerms brandImgAgg = bucket.getAggregations().get("brand_img_agg");
        brand.setBrandImg(brandImgAgg.getBuckets().get(0).getKeyAsString());
        brands.add(brand);
    }
    result.setBrands(brands);

    // 5.当前所有商品涉及到的所有分类信息
    List<SearchResult.CatalogVo> catalogs = new ArrayList<>();
    ParsedLongTerms catalogAgg = aggregations.get("catalog_agg");
    for (Terms.Bucket bucket : catalogAgg.getBuckets()) {
        // 封装分类ID
        SearchResult.CatalogVo catalog = new SearchResult.CatalogVo();
        catalog.setCatalogId(bucket.getKeyAsNumber().longValue());
        // 封装分类名
        ParsedStringTerms catalogNameAgg = bucket.getAggregations().get("catalog_name_agg");// 子聚合
        catalog.setCatalogName(catalogNameAgg.getBuckets().get(0).getKeyAsString());
        catalogs.add(catalog);
    }
    result.setCatalogs(catalogs);
    return result;
}
```

### 4.4.页面查询参数封装

```json
keyword
sort
hasstock
skuPrice=1_
attrs
catalog3Id
brandId
```

### 4.5.面包屑导航

```json
描述：
	前端后端都可实现，当前采用后端实现

	1.面包屑是多个属性值筛选，并且可以去掉筛选回到之前的筛选结果
	2.返回对象SearchResult保存了去掉任一筛选属性后的link值（跳转地址）【每一个属性都有自己对应的回退地址】

```

#### 属性

```java
// 6.构建面包屑导航数据
if (!CollectionUtils.isEmpty(param.getAttrs())) {
    // 属性非空才需要面包屑功能
    List<SearchResult.NavVo> navs = param.getAttrs().stream().map(attr -> {
        // attr：15_海思
        SearchResult.NavVo nav = new SearchResult.NavVo();
        String[] arr = attr.split("_");
        nav.setNavName(attrMap.get(Long.parseLong(arr[0])));
        nav.setNavValue(arr[1]);
        // 设置跳转地址（将属性条件置空）【当取消面包屑上的条件时，跳转地址】
        // 解决编码问题，前端参数使用UTF-8编码了
        String encode = null;
        encode = UriEncoder.encode(attr);
//                try {
//                    encode = URLEncoder.encode(attr, "UTF-8");// java将空格转义成了+号
//                    encode = encode.replace("+", "%20");// 浏览器将空格转义成了%20，差异化处理，否则_queryString与encode匹配失败
//                } catch (UnsupportedEncodingException e) {
//                    e.printStackTrace();
//                }
        // 替换掉当前查询属性，剩下的查询条件即是回退地址
        String replace = param.get_queryString().replace("&attrs=" + encode, "");
        nav.setLink("http://search.gulimall.com/list.html?" + replace);// 每一个属性都有自己对应的回退地址

        return nav;
    }).collect(Collectors.toList());
    result.setNavs(navs);
}
```

![1636982925107](1636982925107.png)

#### 品牌和分类

```json
将品牌和分类也放进面包屑
```

```java
// 7.构建面包屑导航数据_品牌
if (!CollectionUtils.isEmpty(param.getBrandId())) {
    List<SearchResult.NavVo> navs = result.getNavs();
    // 多个品牌ID封装成一级面包屑，所以这里只需要一个NavVo
    SearchResult.NavVo nav = new SearchResult.NavVo();
    // 面包屑名称直接使用品牌
    nav.setNavName("品牌");
    StringBuffer buffer = new StringBuffer();
    String replace = "";
    for (Long brandId : param.getBrandId()) {
        // 多个brandId筛选条件汇总为一级面包屑，所以navValue拼接所有品牌名
        buffer.append(brandMap.get(brandId)).append(";");
        // 因为多个brandId汇总为一级面包屑，所以每一个brandId筛选条件都要删除
        replace = replaceQueryString(param, "brandId", brandId.toString());
    }
    nav.setNavValue(buffer.toString());// 品牌拼接值
    nav.setLink("http://search.gulimall.com/list.html?" + replace);// 回退品牌面包屑等于删除所有品牌条件
    navs.add(nav);
}
```

### 4.6.最终版封装返回结果SearchResponse

```java
/**
 * 封装检索结果
 * 1、返回所有查询到的商品
 * 2、分页信息
 * 3、当前所有商品涉及到的所有属性信息
 * 4、当前所有商品涉及到的所有品牌信息
 * 5、当前所有商品涉及到的所有分类信息
 */
private SearchResult buildSearchResuult(SearchResponse response, SearchParam param) {
    SearchResult result = new SearchResult();
    // ==========从命中结果获取===========hits
    SearchHits hits = response.getHits();// 获取命中结果
    // 1.返回所有查询到的商品
    List<SkuEsModel> products = new ArrayList<>();
    if (!ArrayUtils.isEmpty(hits.getHits())) {
        for (SearchHit hit : hits.getHits()) {
            String jsonString = hit.getSourceAsString();// 获取jsonString
            SkuEsModel esModel = JSONObject.parseObject(jsonString, SkuEsModel.class);
            if (StringUtils.isNotBlank(param.getKeyword())) {
                // 关键字不为空，返回结果包含高亮信息
                // 高亮信息
                String skuTitle = hit.getHighlightFields().get("skuTitle").fragments()[0].string();
                esModel.setSkuTitle(skuTitle);
            }
            products.add(esModel);
        }
    }
    result.setProducts(products);
    // 2.分页信息
    long total = hits.getTotalHits().value;
    long totalPages = total % EsConstant.PRODUCT_PAGESIZE == 0 ? total / EsConstant.PRODUCT_PAGESIZE : total / EsConstant.PRODUCT_PAGESIZE + 1;
    result.setPageNum(param.getPageNum());// 当前页码
    result.setTotal(total);// 总记录数
    result.setTotalPages((int) totalPages);// 总页码
    // 导航页码
    List<Integer> pageNavs = new ArrayList<>();
    for (int i = 1; i <= totalPages; i++) {
        pageNavs.add(i);
    }
    result.setPageNavs(pageNavs);

    // ==========从聚合结果获取===========aggregations
    Aggregations aggregations = response.getAggregations();// 获取聚合结果
    // 3.当前所有商品涉及到的所有属性信息
    ArrayList<SearchResult.AttrVo> attrs = new ArrayList<>();
    ParsedNested attrAgg = aggregations.get("attr_agg");
    ParsedLongTerms attrIdAgg = attrAgg.getAggregations().get("attr_id_agg");
    Map<Long, String> attrMap = new HashMap<>();// 面包屑map数据源【属性名】
    for (Terms.Bucket bucket : attrIdAgg.getBuckets()) {
        // 封装属性ID
        SearchResult.AttrVo attr = new SearchResult.AttrVo();
        attr.setAttrId(bucket.getKeyAsNumber().longValue());
        // 封装属性名
        ParsedStringTerms attrNameAgg = bucket.getAggregations().get("attr_name_agg");
        attr.setAttrName(attrNameAgg.getBuckets().get(0).getKeyAsString());
        // 封装属性值
        ParsedStringTerms attrValueAgg = bucket.getAggregations().get("attr_value_agg");
        List<String> attrValue = attrValueAgg.getBuckets().stream()
                .map(valueBucket -> valueBucket.getKeyAsString())
                .collect(Collectors.toList());
        attr.setAttrValue(attrValue);
        attrs.add(attr);
        // 构建面包屑数据源
        if (!CollectionUtils.isEmpty(param.getAttrs()) && !attrMap.containsKey(attr.getAttrId())) {
            attrMap.put(attr.getAttrId(), attr.getAttrName());
        }
    }
    result.setAttrs(attrs);

    // 4.当前所有商品涉及到的所有品牌信息
    List<SearchResult.BrandVo> brands = new ArrayList<>();
    ParsedLongTerms brandAgg = aggregations.get("brand_agg");
    Map<Long, String> brandMap = new HashMap<>();// 面包屑map数据源【品牌】
    for (Terms.Bucket bucket : brandAgg.getBuckets()) {
        // 封装品牌ID
        SearchResult.BrandVo brand = new SearchResult.BrandVo();
        brand.setBrandId(bucket.getKeyAsNumber().longValue());
        // 封装品牌名
        ParsedStringTerms brandNameAgg = bucket.getAggregations().get("brand_name_agg");
        brand.setBrandName(brandNameAgg.getBuckets().get(0).getKeyAsString());
        // 封装品牌图片
        ParsedStringTerms brandImgAgg = bucket.getAggregations().get("brand_img_agg");
        brand.setBrandImg(brandImgAgg.getBuckets().get(0).getKeyAsString());
        brands.add(brand);
        // 构建面包屑数据源
        if (!CollectionUtils.isEmpty(param.getBrandId()) ) {
            brandMap.put(brand.getBrandId(), brand.getBrandName());
        }
    }
    result.setBrands(brands);

    // 5.当前所有商品涉及到的所有分类信息
    List<SearchResult.CatalogVo> catalogs = new ArrayList<>();
    ParsedLongTerms catalogAgg = aggregations.get("catalog_agg");
    String catalogName = null;// 面包屑map数据源【分类】
    for (Terms.Bucket bucket : catalogAgg.getBuckets()) {
        // 封装分类ID
        SearchResult.CatalogVo catalog = new SearchResult.CatalogVo();
        catalog.setCatalogId(bucket.getKeyAsNumber().longValue());
        // 封装分类名
        ParsedStringTerms catalogNameAgg = bucket.getAggregations().get("catalog_name_agg");// 子聚合
        catalog.setCatalogName(catalogNameAgg.getBuckets().get(0).getKeyAsString());
        catalogs.add(catalog);
        // 构建面包屑数据源
        if (catalog.getCatalogId().equals(param.getCatalog3Id())) {
            catalogName = catalog.getCatalogName();
        }
    }
    result.setCatalogs(catalogs);

    // 6.构建面包屑导航数据_属性
    if (!CollectionUtils.isEmpty(param.getAttrs())) {
        // 属性非空才需要面包屑功能
        List<SearchResult.NavVo> navs = param.getAttrs().stream().map(attr -> {
            // attr：15_海思
            SearchResult.NavVo nav = new SearchResult.NavVo();
            String[] arr = attr.split("_");
            // 封装筛选属性ID集合【给前端判断哪些属性是筛选条件，从而隐藏显示属性栏，显示在面包屑中】
            result.getAttrIds().add(Long.parseLong(arr[0]));
            // 面包屑名字：属性名
            nav.setNavName(attrMap.get(Long.parseLong(arr[0])));
            // 面包屑值：属性值
            nav.setNavValue(arr[1]);
            // 设置跳转地址（将属性条件置空）【当取消面包屑上的条件时，跳转地址】
            String replace = replaceQueryString(param, "attrs", attr);
            nav.setLink("http://search.gulimall.com/list.html?" + replace);// 每一个属性都有自己对应的回退地址

            return nav;
        }).collect(Collectors.toList());
        result.setNavs(navs);
    }

    // 7.构建面包屑导航数据_品牌
    if (!CollectionUtils.isEmpty(param.getBrandId())) {
        List<SearchResult.NavVo> navs = result.getNavs();
        // 多个品牌ID封装成一级面包屑，所以这里只需要一个NavVo
        SearchResult.NavVo nav = new SearchResult.NavVo();
        // 面包屑名称直接使用品牌
        nav.setNavName("品牌");
        StringBuffer buffer = new StringBuffer();
        String replace = "";
        for (Long brandId : param.getBrandId()) {
            // 多个brandId筛选条件汇总为一级面包屑，所以navValue拼接所有品牌名
            buffer.append(brandMap.get(brandId)).append(";");
            // 因为多个brandId汇总为一级面包屑，所以每一个brandId筛选条件都要删除
            replace = replaceQueryString(param, "brandId", brandId.toString());
        }
        nav.setNavValue(buffer.toString());// 品牌拼接值
        nav.setLink("http://search.gulimall.com/list.html?" + replace);// 回退品牌面包屑等于删除所有品牌条件
        navs.add(nav);
    }

    // 构建面包屑导航数据_分类
    if (param.getCatalog3Id() != null) {
        List<SearchResult.NavVo> navs = result.getNavs();
        SearchResult.NavVo nav = new SearchResult.NavVo();
        nav.setNavName("分类");
        nav.setNavValue(catalogName);// 分类名
        StringBuffer buffer = new StringBuffer();
//            String replace = replaceQueryString(param, "catalog3Id", param.getCatalog3Id().toString());
//            nav.setLink("http://search.gulimall.com/list.html?" + replace);
        navs.add(nav);
    }


    return result;
}

private String replaceQueryString(SearchParam param, String key, String value) {
    // 解决编码问题，前端参数使用UTF-8编码了
    String encode = null;
    encode = UriEncoder.encode(value);
//                try {
//                    encode = URLEncoder.encode(attr, "UTF-8");// java将空格转义成了+号
//                    encode = encode.replace("+", "%20");// 浏览器将空格转义成了%20，差异化处理，否则_queryString与encode匹配失败
//                } catch (UnsupportedEncodingException e) {
//                    e.printStackTrace();
//                }
    // TODO BUG，第一个参数不带&
    // 替换掉当前查询条件，剩下的查询条件即是回退地址
    String replace = param.get_queryString().replace("&" + key + "=" + encode, "");
    return replace;
}
```

# 五、商品详情页

## 1.环境搭建

```java
1.增加DNS解析：
	192.168.56.10 item.gulimall.com
	
目前为止完整DNS模板：
# gulimall
192.168.56.10 gulimall.com
192.168.56.10 search.gulimall.com
192.168.56.10 item.gulimall.com

2.配置nginx域名拦截item.gulimall.com【*.gulimall.com;】
vi ../mydata/nginx/conf/conf.d/gulimall.conf，使得server_name可以匹配item.gulimall.com

server {
    listen       80;
    server_name gulimall.com *.gulimall.com;

    location /static/ {
        root /usr/share/nginx/html;
    }

    location / {
        proxy_set_header Host $host;
        proxy_pass http://gulimall;
    }

    error_page   500 502 503 504  /50x.html;
    location = /50x.html {
        root   /usr/share/nginx/html;
    }
}

3.配置网关
- id: gulimall_product_route
  uri: lb://gulimall-product
  predicates:
    - Host=gulimall.com,item.gulimall.com

4.拷贝item.html到product模块

5.拷贝静态资源到nginx以下目录中
/mydata/nginx/html/static/item

6.item.html中静态资源访问路径添加前缀【因为nginx配置location，访问/static的都转到/usr/share/nginx/html路径】
/static/item/

7.新增控制器，渲染商品详情
ItemController
```

```java
@Controller
public class ItemController {

    @Resource
    private SkuInfoService skuInfoService;

    /**
     * 展示当前sku的详情
     * @param skuId
     * @return
     */
    @GetMapping("/{skuId}.html")
    public String skuItem(@PathVariable("skuId") Long skuId, Model model) throws ExecutionException, InterruptedException {
        System.out.println("准备查询" + skuId + "详情");

        /**
         * 1、sku基本信息【标题、副标题、价格】pms_sku_info
         * 2、sku图片信息【每个sku_id对应了多个图片】pms_sku_images
         * 3、spu下所有sku销售属性组合【不只是当前sku_id所指定的商品】
         * 4、spu商品介绍【】
         * 5、spu规格与包装【参数信息】
         */
        SkuItemVo vos = skuInfoService.item(skuId);
        model.addAttribute("item",vos);
        return "item";
    }
}
```

## 2.查询Sku商品详情

### 2.1.商品详情数据结构

```java
最外层

@Data
public class SkuItemVO {
    /**
     * 1、sku基本信息【标题、副标题、价格】pms_sku_info
     * 2、sku图片信息【每个sku_id对应了多个图片】pms_sku_images
     * 3、spu下所有sku销售属性组合【不只是当前sku_id所指定的商品】
     * 4、spu商品介绍【】
     * 5、spu规格与包装【参数信息】
     */

    //1、sku基本信息（pms_sku_info）【默认图片、标题、副标题、价格】
    private SkuInfoEntity info;

    private boolean hasStock = true;// 是否有货

    //2、sku图片信息（pms_sku_images）
    private List<SkuImagesEntity> images;

    //3、当前sku所属spu下的所有销售属性组合（pms_sku_sale_attr_value）
    private List<SkuItemSaleAttrVO> saleAttr;

    //4、spu商品介绍（pms_spu_info_desc）【描述图片】
    private SpuInfoDescEntity desc;

    //5、spu规格参数信息（pms_attr）【以组为单位】
    private List<SpuItemAttrGroupVO> groupAttrs;
}
```

```java
销售属性组合
@Data
@ToString
public class SkuItemSaleAttrVO {
    /**
     * 1.销售属性对应1个attrName
     * 2.销售属性对应n个attrValue
     * 3.n个sku包含当前销售属性（所以前端根据skuId交集区分销售属性的组合【笛卡尔积】）
     */
    private Long attrId;
    private String attrName;
    private List<AttrValueWithSkuIdVO> attrValues;
}

@Data
public class AttrValueWithSkuIdVO {
    private String attrValue;
    private String skuIds;
}
```

```java
规格参数
@Data
@ToString
public class SpuItemAttrGroupVO {
    private String groupName;
    private List<Attr> attrs;
}

@Data
public class Attr {

    private Long attrId;
    private String attrName;
    private String attrValue;

    private Integer searchType;
    private Integer valueType;
    private String icon;
    private String valueSelect;
    private Integer attrType;
    private Long enable;
    private Long catelogId;
    private Integer showDesc;
}
```

### 2.2.service查询VO返回

```java
/**
 * 查询skuId商品信息，封装VO返回
 */
@Override
public SkuItemVO item(Long skuId) {
    SkuItemVO result = new SkuItemVO();
    // 1.获取sku基本信息（pms_sku_info）【默认图片、标题、副标题、价格】
    SkuInfoEntity skuInfo = getById(skuId);
    result.setInfo(skuInfo);
    Long spuId = skuInfo.getSpuId();// 获取spuId
    Long catalogId = skuInfo.getCatalogId();// 获取三级分类Id

    // 2.获取sku图片信息（pms_sku_images）
    List<SkuImagesEntity> images = skuImagesService.getImagesBySkuId(skuId);
    result.setImages(images);

    // 3.获取当前sku所属spu下的所有销售属性组合（pms_sku_info、pms_sku_sale_attr_value）
    List<SkuItemSaleAttrVO> saleAttr = skuSaleAttrValueService.getSaleAttrBySpuId(spuId);
    result.setSaleAttr(saleAttr);

    // 4.获取spu商品介绍（pms_spu_info_desc）【描述图片】
    SpuInfoDescEntity desc = spuInfoDescService.getById(spuId);
    result.setDesc(desc);

    // 5.获取spu规格参数信息（pms_product_attr_value、pms_attr_attrgroup_relation、pms_attr_group）
    List<SpuItemAttrGroupVO> groupAttrs = attrGroupService.getAttrGroupWithAttrsBySpuId(spuId, catalogId);
    result.setGroupAttrs(groupAttrs);

    return result;
}
```

### 2.3.获取spu销售属性组合（笛卡尔积）

查询所有属性的skuId交集，组成sku笛卡尔积

![1637850295715](1637850295715.png)

```xml
3.获取当前sku所属spu下的所有销售属性组合（pms_sku_info、pms_sku_sale_attr_value）
// 1.通过spuId查询所有sku（pms_sku_info）
// 2.查询sku涉及到的所有销售属性（pms_sku_sale_attr_value）
/**
 * 1.销售属性对应1个attrName
 * 2.销售属性对应n个attrValue
 * 3.n个sku包含当前销售属性（所以前端根据skuId交集区分销售属性的组合【笛卡尔积】）
 *  sku_ids用,切割成List<String> skuIds
 */
<resultMap id="skuItemSaleAttrVO" type="com.atguigu.common.vo.product.SkuItemSaleAttrVO">
    <result column="attr_id" property="attrId"></result>
    <result column="attr_name" property="attrName"></result>
    <collection property="attrValues" ofType="com.atguigu.common.vo.product.AttrValueWithSkuIdVO">
        <result column="attr_value" property="attrValue"></result>
        <result column="sku_ids" property="skuIds"></result>
    </collection>
</resultMap>

<select id="getSaleAttrBySpuId" resultMap="skuItemSaleAttrVO">
    SELECT ssav.attr_id                        attr_id,
           ssav.attr_name                      attr_name,
           ssav.attr_value,
           group_concat(DISTINCT info.sku_id ) sku_ids
    FROM pms_sku_info info
             LEFT JOIN pms_sku_sale_attr_value ssav ON ssav.sku_id = info.sku_id
    WHERE info.spu_id = #{spuId}
    GROUP BY ssav.attr_id,
             ssav.attr_name,
             ssav.attr_value
</select>
```

选中销售属性，跳转选中商品页

![1637851295471](1637851295471.png)

### 2.4.获取spu规格参数信息

```xml
5.获取spu规格参数信息（pms_product_attr_value、pms_attr_attrgroup_relation、pms_attr_group）
// 1.通过spuId查询所有属性值（pms_product_attr_value）
// 2.通过attrId关联所有属性分组（pms_attr_attrgroup_relation）
// 3.通过attrGroupId + catalogId关联属性分组名称（pms_attr_group）

<!--只要有嵌套属性就要封装自定义结果集-->
<resultMap id="spuAttrGroup" type="com.atguigu.common.vo.product.SpuItemAttrGroupVO">
    <result property="groupName" column="attr_group_name"/>
    <collection property="attrs" ofType="com.atguigu.common.vo.product.Attr">
        <result property="attrId" column="attr_id"></result>
        <result property="attrName" column="attr_name"></result>
        <result property="attrValue" column="attr_value"></result>
    </collection>
</resultMap>

<select id="getAttrGroupWithAttrsBySpuId" resultMap="spuAttrGroup">
    SELECT pav.spu_id,
           ag.attr_group_id,
           ag.attr_group_name,
           pav.attr_id,
           pav.attr_name,
           pav.attr_value
    FROM pms_product_attr_value pav
             LEFT JOIN pms_attr_attrgroup_relation aar ON pav.attr_id = aar.attr_id
             LEFT JOIN pms_attr_group ag ON aar.attr_group_id = ag.attr_group_id
    WHERE pav.spu_id = #{spuId}
      AND ag.catelog_id = #{catalogId}
</select>
```

### 2.5.异步编排优化商品详情

```java
/**
 * 查询skuId商品信息，封装VO返回
 */
@Override
public SkuItemVO item(Long skuId) throws ExecutionException, InterruptedException {
    SkuItemVO result = new SkuItemVO();

    CompletableFuture<SkuInfoEntity> skuInfoFuture = CompletableFuture.supplyAsync(() -> {
        // 1.获取sku基本信息（pms_sku_info）【默认图片、标题、副标题、价格】
        SkuInfoEntity skuInfo = getById(skuId);
        result.setInfo(skuInfo);
        return skuInfo;
    }, executor);

    CompletableFuture<Void> imagesFuture = CompletableFuture.runAsync(() -> {
        // 2.获取sku图片信息（pms_sku_images）
        List<SkuImagesEntity> images = skuImagesService.getImagesBySkuId(skuId);
        result.setImages(images);
    }, executor);

    CompletableFuture<Void> saleAttrFuture = skuInfoFuture.thenAcceptAsync((skuInfo) -> {
        // 3.获取当前sku所属spu下的所有销售属性组合（pms_sku_info、pms_sku_sale_attr_value）
        List<SkuItemSaleAttrVO> saleAttr = skuSaleAttrValueService.getSaleAttrBySpuId(skuInfo.getSpuId());
        result.setSaleAttr(saleAttr);
    }, executor);

    CompletableFuture<Void> descFuture = skuInfoFuture.thenAcceptAsync((skuInfo) -> {
        // 4.获取spu商品介绍（pms_spu_info_desc）【描述图片】
        SpuInfoDescEntity desc = spuInfoDescService.getById(skuInfo.getSpuId());
        result.setDesc(desc);
    }, executor);

    CompletableFuture<Void> groupAttrsFuture = skuInfoFuture.thenAcceptAsync((skuInfo) -> {
        // 5.获取spu规格参数信息（pms_product_attr_value、pms_attr_attrgroup_relation、pms_attr_group）
        List<SpuItemAttrGroupVO> groupAttrs = attrGroupService.getAttrGroupWithAttrsBySpuId(skuInfo.getSpuId(), skuInfo.getCatalogId());
        result.setGroupAttrs(groupAttrs);
    }, executor);

    // 6.等待所有任务都完成
    CompletableFuture.allOf(imagesFuture, saleAttrFuture, descFuture, groupAttrsFuture).get();

    return result;
}
```

# 六、认证服务（认证中心）

![1637885853846](1637885853846.png)

## 1.社交登录 & 单点登录

```java
OAuth: OAuth(开放授权）是一个开放标准，允许用户授权第三方网站访问他们存储在另外的服务提供者上的信息,而不需要将用户名和密码提供给第三方网站或分享他们数据的所有内容。

OAuth2.0：【一种协议标准，现在都使用OAuth2.0】实际上就是服务器开放了一些查询用户信息的OpenAPI（例如获取用户信息，动态同步，照片，日志，分享等），为了保护用户数据的安全和隐私，第三方网站访问用户数据前都需要显式的向用户征求授权，授权成功会拿到token，根据token调用OpenAPI获取用户信息

社交登录：
	利用其它网站的OAuth2.0特性实现gulimall社交登录功能
单点登录：
    跨域保存登录状态
```

## 2.环境搭建

新建模块：

![1637885953423](1637885953423.png)

添加依赖：

 ![1637886386630](1637886386630.png)

```xml
1.创建认证模块，使用spring initializr
name		谷粒商城-认证中心（社交登录、OAuth2.0、单点登录）
group 		com.atguigu.gulimall
artifact 	gulimall-auth-server
packagename	com.atguigu.gulimall.auth

2.添加依赖
devtools、lombok、spring web、thymeleaf、openfeign

3.修改springboot版本
  修改springcloud版本
  引入common模块
  主pom引入当前model
  
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.3.2.RELEASE</version>
        <relativePath/> <!-- lookup parent from repository -->
    </parent>

	<properties>
        <java.version>1.8</java.version>
        <spring-cloud.version>Hoxton.SR6</spring-cloud.version>
    </properties>

    <!--公共模块-->
    <dependency>
        <groupId>com.atguigu.gulimall</groupId>
        <artifactId>gulimall-common</artifactId>
        <version>0.0.1-SNAPSHOT</version>
        <exclusions>
            <exclusion>
                <groupId>com.baomidou</groupId>
                <artifactId>mybatis-plus-boot-starter</artifactId>
            </exclusion>
        </exclusions>
    </dependency>

    <modules>
        <module>gulimall-coupon</module>
        <module>gulimall-member</module>
        <module>gulimall-order</module>
        <module>gulimall-product</module>
        <module>gulimall-ware</module>
        <module>renren-fast</module>
        <module>renren-generator</module>
        <module>gulimall-common</module>
        <module>gulimall-gateway</module>
        <module>gulimall-third-party</module>
        <module>gulimall-search</module>
        <module>gulimall-auth-server</module>
    </modules>

4.将当前模块注册到nacos
配置：
server:
  port: 20000
spring:
  application:
    name: gulimall-auth-server
  cloud:
    nacos:
      discovery:
        server-addr: 127.0.0.1:8848

5.启动类注解：
@EnableFeignClients
@EnableDiscoveryClient
@SpringBootApplication
public class GulimallAuthServerApplication {

    public static void main(String[] args) {
        SpringApplication.run(GulimallAuthServerApplication.class, args);
    }

}

6.引入登录页面+注册页面，修改静态资源地址
login.html  reg.html
<a href="http://gulimall.com/"><img src="/static/login/JD_img/logo.jpg"/></a>
<script src="/static/reg/js/jQuery/jquery-3.1.1.js"></script>

7.本地添加dns解析
# gulimall
192.168.56.10 gulimall.com
192.168.56.10 search.gulimall.com
192.168.56.10 item.gulimall.com
192.168.56.10 auth.gulimall.com

8.拷贝静态资源到nginx中
/mydata/nginx/html/static，新建文件夹login、reg

9.配置网关转发
      - id: gulimall_auth_route
        uri: lb://gulimall-auth-server
        predicates:
        - Host=auth.gulimall.com
```



 ![1637935781110](1637935781110.png)

## 3.SpringMVC viecontroller（视图控制器）

```java
功能：
	发送一个请求，直接跳转一个页面，例：
    /**
     * 访问登录页面
     */
    @GetMapping(value = "/login.html")
    public String loginPage(HttpSession session) {
        return "login";
    }
    但是这样会造成所有请求都需要一个getMapping方法映射页面，springmvc的解决方法：

1.添加配置类继承WebMvcConfigurer【必须使用GET请求访问】
@Configuration
public class GulimallWebConfig implements WebMvcConfigurer {

    /**
     * 视图映射:拦截请求跳转页面
     */
    @Override
    public void addViewControllers(ViewControllerRegistry registry) {
        registry.addViewController("/reg.html").setViewName("reg");
    }
}

```

## 4.发送验证码相关接口

### 4.1.js代码60秒倒计时

```js
	$(function () {
        $("#sendCode").click(function () {
            //2、倒计时
            if ($(this).hasClass("disabled")) {
                //正在倒计时中
            } else {
                //1、给指定手机号发送验证码
                $.get("/sms/sendCode?phone=" + $("#phoneNum").val(), function (data) {
                    if (data.code != 0) {
                        alert(data.msg);
                    }
                });
                timeoutChangeStyle();// 开始倒计时
            }
        });
    });

    var num = 60;

    function timeoutChangeStyle() {
        $("#sendCode").attr("class", "disabled");// 已经点击发送验证码后，当前按钮不可点击
        if (num == 0) {
            $("#sendCode").text("发送验证码");// 60秒后，文本秀嘎斯为发送验证码
            num = 60;
            $("#sendCode").attr("class", "");// 60秒后，可以点击
        } else {
            var str = num + "s 后再次发送";
            $("#sendCode").text(str);
            setTimeout("timeoutChangeStyle()", 1000);// 一秒后执行timeoutChangeStyle()
            num--;
        }
    }

```

### 4.2.第三方服务_发送短信

```java
1.搜索短信接口，购买一个5条的短信
https://market.aliyun.com/products/57126001/cmapi024822.html?spm=5176.2020520132.101.2.70a87218D92LLv#sku=yuncode1882200000

2.购买成功后进入云市场，记录AppKey、AppSecret、AppCode
https://market.console.aliyun.com/?spm=5176.12818093.top-nav.dbutton.5adc16d0RrmD95#/?_k=pdf92o

3.参照案例，请求头使用Authorization作为key + 值使用AppCode的值来验证身份
/**
 * 短信配置类
 * @Author: wanzenghui
 * @Date: 2021/11/27 23:01
 */
@Configuration
public class SmsConfig {

    @Bean
    @ConfigurationProperties(prefix = "spring.cloud.alicloud.sms")
    public SmsServiceImpl smsService() {
        return new SmsServiceImpl();
    }
}

/**
 * 短信服务实现类
 * @Author: wanzenghui
 * @Date: 2021/11/27 22:58
 */
@Data
public class SmsServiceImpl implements SmsService {

    private String host;
    private String path;
    private String appcode;
    private String sign;
    private String skin;

    @Override
    public Boolean sendCode(String phone, String code) {
        String urlSend = host + path + "?code=" + code + "&phone=" + phone + "&sign=" + sign + "&skin=" + skin ; // 拼接请求链接
        try {
            URL url = new URL(urlSend);
            HttpURLConnection httpURLCon = (HttpURLConnection) url.openConnection();
            httpURLCon.setRequestProperty("Authorization", "APPCODE " + appcode);// 格式Authorization:APPCODE
            // (中间是英文空格)
            int httpCode = httpURLCon.getResponseCode();
            if (httpCode == 200) {
                String json = read(httpURLCon.getInputStream());
                System.out.println("正常请求计费(其他均不计费)");
                System.out.println("获取返回的json:");
                System.out.print(json);
            } else {
                Map<String, List<String>> map = httpURLCon.getHeaderFields();
                String error = map.get("X-Ca-Error-Message").get(0);
                if (httpCode == 400 && error.equals("Invalid AppCode `not exists`")) {
                    System.out.println("AppCode错误 ");
                } else if (httpCode == 400 && error.equals("Invalid Url")) {
                    System.out.println("请求的 Method、Path 或者环境错误");
                } else if (httpCode == 400 && error.equals("Invalid Param Location")) {
                    System.out.println("参数错误");
                } else if (httpCode == 403 && error.equals("Unauthorized")) {
                    System.out.println("服务未被授权（或URL和Path不正确）");
                } else if (httpCode == 403 && error.equals("Quota Exhausted")) {
                    System.out.println("套餐包次数用完 ");
                } else {
                    System.out.println("参数名错误 或 其他错误");
                    System.out.println(error);
                }
            }
        } catch (MalformedURLException e) {
            System.out.println("URL格式错误");
        } catch (UnknownHostException e) {
            System.out.println("URL地址错误");
        } catch (Exception e) {
            // 打开注释查看详细报错异常信息
            // e.printStackTrace();
        }
        return true;
    }

    /*
     * 读取返回结果
     */
    private static String read(InputStream is) throws IOException {
        StringBuffer sb = new StringBuffer();
        BufferedReader br = new BufferedReader(new InputStreamReader(is));
        String line = null;
        while ((line = br.readLine()) != null) {
            line = new String(line.getBytes(), "utf-8");
            sb.append(line);
        }
        br.close();
        return sb.toString();
    }
}

/**
 * 短信服务
 * @Author: wanzenghui
 * @Date: 2021/11/27 23:20
 */
@RestController
@RequestMapping("/sms")
public class SmsController {

    @Autowired
    SmsServiceImpl smsService;

    /**
     * 发送短信验证码
     * 提供其他模块调用
     * @param phone 号码
     * @param code  验证码
     */
    @GetMapping("/test")
    public R sendCode(@RequestParam("phone") String phone, @RequestParam("code") String code) {
        smsService.sendCode(phone, code);
        return R.ok();
    }
}
```

购买：

![1637942839317](1637942839317.png)

进入云市场：

![1637943295896](1637943295896.png)

### 4.3.认证模块_远程调用发送短信验证码

```java
@Controller
public class LoginController {

    @Autowired
    ThirdPartFeignService thirdPartFeignService;

    /**
     * 发送短信验证码
     * @param phone 号码
     * @param code  验证码
     */
    @ResponseBody
    @GetMapping("/sms/sendCode")
    public R sendCode(@RequestParam("phone") String phone) {
        String code = UUID.randomUUID().toString().substring(0, 5);
        thirdPartFeignService.sendCode(phone, code);
        return R.ok();
    }
}
```

### 4.4.认证模块_发送短信接口完善（60秒防刷）

```xml
1.引入redis
<!--redis-->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-redis</artifactId>
</dependency>

2.配置
spring:
  redis:
    host: 192.168.56.10
    port: 6379

3.需要解决一些问题：
	1）60秒间隔发送
	2）接口防刷
```

```java
/**
 * 发送短信验证码
 *
 * @param phone 号码
 * @param code  验证码
 */
@ResponseBody
@GetMapping("/sms/sendCode")
public R sendCode(@RequestParam(name = "phone", required = true) String phone) {
    // 1.判断60秒间隔发送，防刷
    String _code = redisTemplate.opsForValue().get(AuthConstant.SMS_CODE_CACHE_PREFIX + phone);
    if (StringUtils.isNotBlank(_code) && System.currentTimeMillis() - Long.parseLong(_code.split("_")[1]) < 60000) {
        // 调用接口小于60秒间隔不允许重新发送新的验证码
        return R.error(BizCodeEnume.SMS_CODE_EXCEPTION);
    }

    // 2.验证码存入缓存
    String code = UUID.randomUUID().toString().substring(0, 5);
    // 验证码缓存到redis中（并且记录当前时间戳）
    redisTemplate.opsForValue().set(AuthConstant.SMS_CODE_CACHE_PREFIX + phone, code + "_" + System.currentTimeMillis(), 10, TimeUnit.MINUTES);

    // 3.发送验证码
    thirdPartFeignService.sendCode(phone, code);

    return R.ok();
}
```

## 5.注册接口

### 5.1.参数校验

```java
/**
 * 注册使用的vo，使用JSR303校验
 */
@Data
public class UserRegisterVO {

    @NotEmpty(message = "用户名必须提交")
    @Length(min = 6, max = 19, message="用户名长度必须是6-18字符")
    private String userName;

    @NotEmpty(message = "密码必须填写")
    @Length(min = 6,max = 18,message = "密码长度必须是6—18位字符")
    private String password;

    @NotEmpty(message = "手机号必须填写")
    @Pattern(regexp = "^[1]([3-9])[0-9]{9}$", message = "手机号格式不正确")
    private String phone;

    @NotEmpty(message = "验证码必须填写")
    private String code;

}
```

### 5.2.异常结果封装+重定向（防刷+分布式session）

```java
// 1.参数校验
if (result.hasErrors()) {
    // 校验出错，返回注册页
    Map<String, String> errMap = new HashMap<>();
    result.getFieldErrors().forEach(err -> errMap.put(err.getField(), err.getDefaultMessage()));
    // 封装异常返回前端显示
    attributes.addFlashAttribute("errors", errMap);// flash，session中的数据只使用一次
    return "redirect:http://auth.gulimall.com/reg.html";// 采用重定向有一定防刷功能
    // 1、return "redirect:http://auth.gulimall.com/reg.html"【采用】 重定向Get请求【配合RedirectAttributes共享数据】
    // 2、return "redirect:http:/reg.html"                   【采用】 重定向Get请求，省略当前服务url【配合RedirectAttributes共享数据】
    // 3、return "redirect:/reg.html"                                重定向Get请求，使用视图控制器拦截请求并映射reg视图【配合RedirectAttributes共享数据】【bug：会以ip+port来重定向】
    // 4、return "forward:http://auth.gulimall.com/reg.html";        请求转发与当前请求方式一致（Post请求）【配合Model共享数据】【异常404：当前/reg.html不存在post请求】
    // 5、return "forward:http:/reg.html";                           请求转发与当前请求方式一致（Post请求），省略当前服务url 【配合Model共享数据】【异常404：当前/reg.html不存在post请求】
    // 6、return "forward:/reg.html";                                请求转发与当前请求方式一致（Post请求），使用视图控制器拦截请求并映射reg视图【配合Model共享数据】【异常405：Request method 'POST' not supported，视图控制器必须使用GET请求访问，而当前请求转发使用post方式，导致异常】
    // 7、return "reg";                                              视图解析器前后拼串查找资源返回【配合Model共享数据】
}
```

### 5.3.验证码校验

```java
// 2.验证码校验
String code = user.getCode();
String redisCode = redisTemplate.opsForValue().get(AuthConstant.SMS_CODE_CACHE_PREFIX + user.getPhone());
if (StringUtils.isBlank(redisCode)) {
    // 验证码过期
    Map<String, String> errMap = new HashMap<>();
    errMap.put("code", "验证码失效");
    // 封装异常返回前端显示
    attributes.addFlashAttribute("errors", errMap);// flash，session中的数据只使用一次
    return "redirect:http://auth.gulimall.com/reg.html";// 采用重定向有一定防刷功能
}
if (!code.equals(redisCode.split("_")[0])) {
    // 验证码错误
    Map<String, String> errMap = new HashMap<>();
    errMap.put("code", "验证码错误");
    // 封装异常返回前端显示
    attributes.addFlashAttribute("errors", errMap);// flash，session中的数据只使用一次
    return "redirect:http://auth.gulimall.com/reg.html";// 采用重定向有一定防刷功能
}
```

### 5.4.认证模块_注册接口

```java
/**
 * 注册接口
 *
 * @param vo         接收注册信息
 * @param result     接收参数校验结果
 * @param attributes 重定向保存数据（原理：使用session，重定向请求后根据cookie拿到session的数据）TODO 分布式session
 */
@PostMapping(value = "/register")
public String register(@Valid UserRegisterVO user, BindingResult result, RedirectAttributes attributes) {
    // 1.参数校验
    if (result.hasErrors()) {
        // 校验出错，返回注册页
        Map<String, String> errMap = new HashMap<>();
        result.getFieldErrors().forEach(err -> errMap.put(err.getField(), err.getDefaultMessage()));
        // 封装异常返回前端显示
        attributes.addFlashAttribute("errors", errMap);// flash，session中的数据只使用一次
        return "redirect:http://auth.gulimall.com/reg.html";// 采用重定向有一定防刷功能
        // 1、return "redirect:http://auth.gulimall.com/reg.html"【采用】 重定向Get请求【配合RedirectAttributes共享数据】
        // 2、return "redirect:http:/reg.html"                   【采用】 重定向Get请求，省略当前服务url【配合RedirectAttributes共享数据】
        // 3、return "redirect:/reg.html"                                重定向Get请求，使用视图控制器拦截请求并映射reg视图【配合RedirectAttributes共享数据】【bug：会以ip+port来重定向】
        // 4、return "forward:http://auth.gulimall.com/reg.html";        请求转发与当前请求方式一致（Post请求）【配合Model共享数据】【异常404：当前/reg.html不存在post请求】
        // 5、return "forward:http:/reg.html";                           请求转发与当前请求方式一致（Post请求），省略当前服务url 【配合Model共享数据】【异常404：当前/reg.html不存在post请求】
        // 6、return "forward:/reg.html";                                请求转发与当前请求方式一致（Post请求），使用视图控制器拦截请求并映射reg视图【配合Model共享数据】【异常405：Request method 'POST' not supported，视图控制器必须使用GET请求访问，而当前请求转发使用post方式，导致异常】
        // 7、return "reg";                                              视图解析器前后拼串查找资源返回【配合Model共享数据】
    }

    // 2.验证码校验
    String code = user.getCode();
    String redisCode = redisTemplate.opsForValue().get(AuthConstant.SMS_CODE_CACHE_PREFIX + user.getPhone());
    if (StringUtils.isBlank(redisCode)) {
        // 验证码过期
        Map<String, String> errMap = new HashMap<>();
        errMap.put("code", "验证码失效");
        // 封装异常返回前端显示
        attributes.addFlashAttribute("errors", errMap);// flash，session中的数据只使用一次
        return "redirect:http://auth.gulimall.com/reg.html";// 采用重定向有一定防刷功能
    }
    if (!code.equals(redisCode.split("_")[0])) {
        // 验证码错误
        Map<String, String> errMap = new HashMap<>();
        errMap.put("code", "验证码错误");
        // 封装异常返回前端显示
        attributes.addFlashAttribute("errors", errMap);// flash，session中的数据只使用一次
        return "redirect:http://auth.gulimall.com/reg.html";// 采用重定向有一定防刷功能
    }

    // 3.调用login实现注册
    redisTemplate.delete(AuthConstant.SMS_CODE_CACHE_PREFIX + user.getPhone());
    R r = memberFeignService.regist(user);
    if (r.getCode() == 0) {
        // 注册成功，重定向到登录页
        return "redirect:http://auth.gulimall.com/login.html";// 重定向
    } else {
        //　注册失败，封装异常
        HashMap<String, String> errMap = new HashMap<>();
        errMap.put("msg", r.getData("msg", new TypeReference<String>() {
        }));
        attributes.addFlashAttribute("errors", errMap);// flash，session中的数据只使用一次
        return "redirect:http://auth.gulimall.com/reg.html";// 采用重定向有一定防刷功能
    }
}
```

### 5.5.用户模块_注册接口

#### 1）校验与异常机制

```java
// 校验手机号、用户名是否唯一，不唯一抛出异常，由controller处理
```

```java
/**
 * 注册
 */
@PostMapping("/regist")
public R regist(@RequestBody MemberUserRegisterTO user){
    try {
        memberService.regist(user);
        return R.ok();
    } catch (PhoneException ex) {
        return R.error(BizCodeEnume.PHONE_EXIST_EXCEPTION);
    } catch (UsernameException ex) {
        return R.error(BizCodeEnume.USER_EXIST_EXCEPTION);
    } catch (Exception ex) {
        return R.error(ex.getMessage());
    }

}
```

#### 2）密码加密MD5

```java
1.可逆加密与不可逆加密
可逆加密：通过密文根据算法可以推算出明文
不可逆加密：无法推算出明文

2.彩虹表
暴力破解所有值的MD5值存储到数据库，然后存储一个映射表，该映射表称为彩虹表

3.不可逆加密实现方法：MD5、MD5盐值加密
========================================================================
MD5：信息摘要算法，只要一个字节发生变化，结果值就会变化
	- Message Digest algorithm 5，信息摘要算法
		·压缩性:任意长度的数据，算出的MD5值长度都是固定的。
		·容易计算:从原数据计算出MD5值很容易。
		·抗修改性:对原数据进行任何改动，哪怕只修改1个字节，所得到的MD5值都有很大区别。
		·强抗碰撞:想找到两个不同的数据，使它们具有相同的MD5值，是非常困难的。
		·不可逆
【百度网盘秒传功能：计算文件MD5值，如果在百度的服务器里能找到一个一模一样的，就可以使用这个】
========================================================================
MD5盐值加密：【明文相同，盐值不同密文也不同，增加了彩虹表的难度】
	·通过生成随机数与MD5生成字符串进行组合
	·数据库同时存储MD5值与salt值。验证正确性时使用salt进行MD5即可
========================================================================
```

**案例**：

```java
========================================================================
MD5案例：
String s = DigestUtils.md5Hex("123456");// e10adc3949ba59abbe56e057f20f883e
System.out.println(s);
========================================================================
MD5盐值案例：
System.out.println(Md5Crypt.md5Crypt("123456".getBytes()));// 随机盐值，随机MD5值：【盐值：USI.JoH2】【MD5值：$1$USI.JoH2$6hK88QXt9ijipsa/VcnbR0】
System.out.println(Md5Crypt.md5Crypt("123456".getBytes()));// 随机盐值，随机MD5值：【盐值：tCYQRfTB】【MD5值：$1$tCYQRfTB$thopJ/8DcRSObDwXuKxvn1】
System.out.println(Md5Crypt.md5Crypt("123456".getBytes(), "$1$123"));// 固定盐值，固定MD5值：【盐值：123】【MD5值：$1$123$7mft0jKnzzvAdU4t0unTG1】
System.out.println(Md5Crypt.md5Crypt("123456".getBytes(), "$1$123"));// 固定盐值，固定MD5值：【盐值：123】【MD5值：$1$123$7mft0jKnzzvAdU4t0unTG1】
========================================================================
使用spring的MD5+随机盐方法生成密文：
BCryptPasswordEncoder passwordEncoder = new BCryptPasswordEncoder();
String encodedPassword1 = passwordEncoder.encode("123456");//$2a$10$s0yQ/Tz1aiexGqQGBNgmDuUFpCPjMx8L7TvJ60i9mQSBEmNXbSFEO
String encodedPassword2 = passwordEncoder.encode("123456");//$2a$10$eXhMUTIjoS4cpCB3FRjhlu0QYGwTRgh93CefQSk48hPpvQzzDAvIS
System.out.println(passwordEncoder.matches("123456", encodedPassword1));// 校验结果true
System.out.println(passwordEncoder.matches("123456", encodedPassword2));// 校验结果true
========================================================================
```

#### 3）service代码

```java
/**
 * 注册
 */
@Override
public void regist(MemberUserRegisterTO user) throws InterruptedException {
    // 1.加锁
    RLock lock = redissonClient.getLock(MemberConstant.LOCK_KEY_REGIST_PRE + user.getPhone());
    try {
        lock.tryLock(30L, TimeUnit.SECONDS);
        // 2.校验
        // 校验手机号唯一、用户名唯一
        checkPhoneUnique(user.getPhone());
        checkUserNameUnique(user.getUserName());
        // 3.封装保存
        MemberEntity entity = new MemberEntity();
        entity.setUsername(user.getUserName());
        entity.setMobile(user.getPhone());
        // 3.1.设置默认等级信息
        MemberLevelEntity level = memberLevelService.getDefaultLevel();
        entity.setLevelId(level.getId());
        // 3.2.设置密码加密存储
        BCryptPasswordEncoder passwordEncoder = new BCryptPasswordEncoder();
        String encode = passwordEncoder.encode(user.getPassword());
        entity.setPassword(encode);
        this.baseMapper.insert(entity);
    } finally {
        lock.unlock();
    }
}

/**
 * 校验手机号是否唯一
 */
public void checkPhoneUnique(String phone) throws PhoneException {
    Integer count = baseMapper.selectCount(new QueryWrapper<MemberEntity>()
            .eq("mobile", phone));
    if (count > 0)
        throw new PhoneException();
}

/**
 * 校验用户名是否唯一
 */
public void checkUserNameUnique(String userName) throws UsernameException {
    Integer count = baseMapper.selectCount(new QueryWrapper<MemberEntity>()
            .eq("username", userName));
    if (count > 0)
        throw new UsernameException();
}
```

## 6.登录

### 6.0.session原理+springsession原理

```json
session原理：
	1.浏览器存储一个cookie值，jsessionId作为key
	2.浏览器请求服务器时会带上这个cookie，服务器根据jsessionId的值找到对应的session对象
	3.从而可以拿到session中存储的信息（例如用户信息）
	4.session对象存储在内存中
	
springsession原理：
	1.通过CookieSerializer设置cookie相关信息，setCookieName设置cookie的key值（代替jsessionId），并自动生成value值，并且可以setDomainName放大作用域
	2.springsession将session对象存储在redis中
```



### 6.1.认证模块_登录接口

#### 登录成功设置session

```java
/**
 * 登录接口
 */
@PostMapping(value = "/login")
public String login(UserLoginVO user, RedirectAttributes attributes, HttpSession session) {
    // 1.远程调用登录
    R r = memberFeignService.login(user);
    if (r.getCode() == 0) {
        // 2.登录成功，设置session值
        MemberResponseVO data = r.getData(new TypeReference<MemberResponseVO>() {});
        session.setAttribute(AuthConstant.LOGIN_USER, data);
        // 3.重定向，视图可以从session中拿到用户信息
        return "redirect:http://gulimall.com";
    } else {
        // 4.登录失败，封装异常信息重定向返回
        Map<String,String> errors = new HashMap<>();
        errors.put("msg", r.getData("msg",new TypeReference<String>(){}));
        attributes.addFlashAttribute("errors",errors);
        return "redirect:http://auth.gulimall.com/login.html";
    }
}
```

### 6.2.用户模块_登录接口

#### MD5+盐值密码校验

```java
/**
 * 登录
 */
@Override
public MemberEntity login(MemberUserLoginTO user) {
    String loginacct = user.getLoginacct();
    String password = user.getPassword();// 明文

    // 1.查询MD5密文
    MemberEntity entity = baseMapper.selectOne(new QueryWrapper<MemberEntity>()
            .eq("username", loginacct)
            .or()
            .eq("mobile", loginacct));
    if (entity != null) {
        // 2.获取password密文进行校验
        BCryptPasswordEncoder passwordEncoder = new BCryptPasswordEncoder();
        if (passwordEncoder.matches(password, entity.getPassword())) {
            // 登录成功
            return entity;
        }
    }
    // 3.登录失败
    return null;
}
```

### 6.3.社交登录OAuth2.0

```json
一、步骤：【例如登录CSDN】
1.用户点击QQ登录
2.引导跳转到QQ授权页
3.用户输入账号密码点击授权
4.授权成功快速注册，然后登录通过CSDN

二、简介：
OAuth: OAuth(开放授权）是一个开放标准，允许用户授权第三方网站访问他们存储在另外的服务提供者上的信息,而不需要将用户名和密码提供给第三方网站或分享他们数据的所有内容。

OAuth2.0：【一种协议标准，现在都使用OAuth2.0】实际上就是服务器开放了一些查询用户信息的OpenAPI（例如获取用户信息，动态同步，照片，日志，分享等），为了保护用户数据的安全和隐私，第三方网站访问用户数据前都需要显式的向用户征求授权，授权成功会拿到token，根据token调用OpenAPI获取用户信息
             
三、查看下图
	1.QQ授权成功，会重定向到CSDN，并返回授权码
    2.用户根据授权码，请求获得token令牌
    3.带上token令牌访问QQ服务器拿到用户基本信息
```

![1638115820600](1638115820600.png)

#### 6.3.1.微博登录

```
1.登录微博开放平台
https://open.weibo.com/

2.微连接->网站接入->创建新应用：gulimall_wanwan-

3.设置授权回调页+取消授权回调页
我的应用->应用信息->高级信息
授权回调页：
    http://auth.gulimall.com/oauth2.0/weibo/success
取消授权回调页：
    http://gulimall.com/fall

4.参照文档开发社交登录功能
https://open.weibo.com/wiki/%E9%A6%96%E9%A1%B5
->OAuth2.0授权认证
https://open.weibo.com/wiki/%E6%8E%88%E6%9D%83%E6%9C%BA%E5%88%B6%E8%AF%B4%E6%98%8E

5.引导用户进入授权页：【添加授权页+授权回调页】
<a href="https://api.weibo.com/oauth2/authorize?client_id=2129105835&response_type=code&redirect_uri=http://auth.gulimall.com/oauth2.0/weibo/success">
	<img style="width: 50px;height: 18px;" src="/static/login/JD_img/weibo.png"/>
	<!--                        <span>weibo</span>-->
</a>

6.上一步用户授权成功后会重定向到授权页，并返回一个code【OTP，使用一次后便失效】
http://auth.gulimall.com/oauth2.0/weibo/success?code=8bbfd9a8bc1379253e5434d28a41df74

7.根据code换取Access Token【查看postman请求截图，Access Token可以使用多次】
指定client_id、client_secret、redirect_uri、code
https://api.weibo.com/oauth2/access_token?client_id=2129105835&client_secret=YOUR_CLIENT_SECRET&grant_type=authorization_code&redirect_uri=http://auth.gulimall.com/oauth2.0/weibo/success&code=8bbfd9a8bc1379253e5434d28a41df74

8.成功获取Access Token后，可以访问的OpenAPI【查看截图】
我的应用->接口管理->已有权限->访问用户信息

9.重点注意：access token和client_secret一定要后端保存，不能泄露
```

**创建新应用：**

 ![1638109314125](1638109314125.png)

**微博web网站授权流程：**

 ![1638112408280](1638112408280.png)

**postman获取Access Token截图**：

![1638114611893](1638114611893.png)

**OpenAPI已有权限**：

![1638114789401](1638114789401.png)

**根据access token访问用户信息：**

![1638115393374](1638115393374.png)

##### 时序图

![1638198366526](1638198366526.png)

##### 代码实现步骤

```java
1.设置授权回调页+取消授权回调页
登录微博开放平台【https://open.weibo.com/】->我的应用->应用信息->高级信息
授权回调页：
    http://auth.gulimall.com/oauth2.0/weibo/success
取消授权回调页：
    http://gulimall.com/fall

2.拷贝gulimall-third-part的HTTPUtils类到common中，并导入相关依赖

3.点击微博登录请求后端地址
<a href="https://api.weibo.com/oauth2/authorize?client_id=2129105835&response_type=code&redirect_uri=http://auth.gulimall.com/oauth2.0/weibo/success">
	<img style="width: 50px;height: 18px;" src="/static/login/JD_img/weibo.png"/>
	<!--                        <span>weibo</span>-->
</a>
```

```java
4.认证模块_社交登录接口
/**
 * 授权回调页
 *
 * @param code 根据code换取Access Token，且code只能兑换一次Access Token
 */
@GetMapping("/oauth2.0/weibo/success")
public String weibo(@RequestParam("code") String code) throws Exception {
    // 1.根据code换取Access Token
    Map<String, String> headers = new HashMap<>();
    Map<String, String> querys = new HashMap<>();
    Map<String, String> map = new HashMap<>();
    map.put("client_id", "2129105835");
    map.put("client_secret", "201b8aa95794dbb6d52ff914fc8954dc");
    map.put("grant_type", "authorization_code");
    map.put("redirect_uri", "http://auth.gulimall.com/oauth2.0/weibo/success");
    map.put("code", code);
    HttpResponse response = HttpUtils.doPost("https://api.weibo.com", "/oauth2/access_token", headers, querys, map);

    // 2.处理请求返回
    if (response.getStatusLine().getStatusCode() == 200) {
        // 换取Access_Token成功
        String jsonString = EntityUtils.toString(response.getEntity());
        WBSocialUserVO user = JSONObject.parseObject(jsonString, WBSocialUserVO.class);

        // 首次登录自动注册（为当前社交登录用户生成一个会员账号信息，以后这个社交账户就会对应指定的会员）
        // 非首次登录则直接登录成功
        R r = memberAgentService.oauthLogin(user);
        if (r.getCode() == 0) {
            // 登录成功
            MemberResponseVO loginUser = r.getData(new TypeReference<MemberResponseVO>() {
            });
            log.info("登录成功：用户：{}", loginUser.toString());
            // 跳回首页
            return "redirect:http://gulimall.com";
        } else {
            // 登录失败，调回登录页
            return "redirect:http://auth.gulimall.com/login.html";
        }
    } else {
        // 换取Access_Token成功
        return "redirect:http://auth.gulimall.com/login.html";
    }
}
```

```java
5.会员模块_社交登录接口
/**
 * 微博社交登录
 */
@PostMapping("/weibo/oauth2/login")
public R oauthLogin(@RequestBody WBSocialUserTO user) {
    try {
        MemberEntity entity = memberService.login(user);
        return R.ok().setData(entity);
    } catch (Exception ex) {
        return R.error(ex.getMessage());
    }
}

/**
 * 微博社交登录（登录和注册功能合并）
 */
@Override
public MemberEntity login(WBSocialUserTO user) throws Exception {
    // 1.判断当前用户是否已经在本系统注册
    String uid = user.getUid();
    MemberEntity _entity = baseMapper.selectOne(new QueryWrapper<MemberEntity>().eq("weibo_uid", user.getUid()));
    if (_entity != null) {
        // 2.已注册，直接返回
        MemberEntity member = new MemberEntity();
        member.setId(_entity.getId());
        member.setAccessToken(user.getAccessToken());
        member.setExpiresIn(user.getExpiresIn());
        baseMapper.updateById(member);
        // 返回
        _entity.setAccessToken(user.getAccessToken());
        _entity.setExpiresIn(user.getExpiresIn());
        return _entity;
    } else {
        // 3.未注册
        MemberEntity member = new MemberEntity();
        try {
            // 查询当前社交用户的社交账号信息，封装会员信息（查询结果不影响注册结果，所以使用try/catch）
            Map<String, String> queryMap = new HashMap<>();
            queryMap.put("access_token", user.getAccessToken());
            queryMap.put("uid", user.getUid());
            HttpResponse response = HttpUtils.doGet("https://api.weibo.com", "/2/users/show.json", new HashMap<String, String>(), queryMap);
            if (response.getStatusLine().getStatusCode() == 200) {
                //查询成功
                String json = EntityUtils.toString(response.getEntity());
                JSONObject jsonObject = JSON.parseObject(json);
                String name = jsonObject.getString("name");
                String gender = jsonObject.getString("gender");
                String profileImageUrl = jsonObject.getString("profile_image_url");
                // 封装注册信息
                member.setNickname(name);
                member.setGender("m".equals(gender) ? 1 : 0);
                member.setHeader(profileImageUrl);
                member.setCreateTime(new Date());
            }
        } catch (Exception e) {

        }
        member.setWeiboUid(user.getUid());
        member.setAccessToken(user.getAccessToken());
        member.setExpiresIn(user.getExpiresIn());
        //把用户信息插入到数据库中
        baseMapper.insert(member);
        return member;
    }
}
```



#### 6.3.2.微信登录

### 6.4.cookie和session共享问题

```
简介：
1.不能跨域名共享cookie
  认证模块登录成功后设置cookie【domain=auth.gulimall.com】
  然后重定向到首页【domain=gulimall.com】，二者domain不一致，导致cookie不共享
  请求gulimall.com时，浏览器默认不会带上cookie

2.不能跨JVM共享session
  登录成功后session保存userinfo，但是session存在于auth.gulimall.com的JVM上
  与gulimall.com的JVM并不共享，因为session是JVM运行时内存中的数据，JVM之间不共享


```

#### 6.4.1.问题一：不能跨域名共享cookie

```java
跨域情况下，cookie不共享
```

![1638199939948](1638199939948.png)

##### 方案一：子域session共享，放大作用域

```java
放大cookie的作用域
    
1.方法1：自己设置domain
// 首次使用session时，spring会自动颁发cookie设置domain，所以这里手动设置cookie很麻烦，采用springsession的方式颁发父级域名的domain权限
//                Cookie cookie = new Cookie("JSESSIONID", loginUser.getId().toString());
//                cookie.setDomain("gulimall.com");
//                servletResponse.addCookie(cookie);
    
2.使用springsession设置domain放大作用域
```

![1638204106793](1638204106793.png)

![1638204177679](1638204177679.png)

#### 6.4.2.问题二：集群下同一个服务不能跨JVM共享session

```java
1.集群环境下，多个会员服务节点不共享JVM，session不共享
2.不同服务之间也不共享JVM，session不共享
```

![1638202747775](1638202747775.png)

##### 方案一：session复制

```
Tomcat修改配置文件就可以支持。
缺点：
	延迟
	占用带宽
	内存占用【所有Tomcat都需要全量保存数据】
```

![1638203089731](1638203089731.png)

##### 方案二：客户端存储

![1638203358919](1638203358919.png)

##### 方案三：hash一致性

```java
推荐使用
```

![1638203453020](1638203453020.png)

#### 6.4.3.问题三：分布式下不同服务共享session

##### 方案一：统一存储==>本系统采用

```java
推荐使用
```

![1638203593827](1638203593827.png)

##### 方案二：token令牌

```
使用redis共享存储 + springsecurity存token令牌，每个调用接口都带令牌访问
```

### 6.5.使用springsession（各模块）

```json
原理：创建了SpringSession过滤器代替了HttpSession的实现
Our Spring Boot Configuration created a Spring bean named springSessionRepositoryFilter that implements Filter. The springSessionRepositoryFilter bean is responsible for replacing the HttpSession with a custom implementation that is backed by Spring Session.


简介：【各模块都需要使用springsession】
1.解决了子域cookie无法共享的问题，放大了cookie的作用域domain

2.解决了跨JVM不能共享session的问题【问题2和问题3本质上是同一个问题，不同JVM不能共享session】，springsession采用redis统一存储的的方式解决了session共享问题

3.查看文档：
https://docs.spring.io/spring-session/docs/2.2.1.RELEASE/reference/

https://spring.io
=》project
=》springsession
=》learn
=》Reference Doc. 
=》3. Samples and Guides (Start Here)
=》HttpSession with Redis Guide (Source 源码) + HttpSession with Redis Guide （Guide 引导）
```

```java
1.在各服务添加springsession依赖（服务自治）【auth、product、search、member、order、】
<!--redis-->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-redis</artifactId>
</dependency>
<!--整合springsession，实现session共享-->
<dependency>
    <groupId>org.springframework.session</groupId>
    <artifactId>spring-session-data-redis</artifactId>
</dependency>

2.属性配置
server:
  servlet:
    session:
      timeout: 30m
spring:
  redis:
    host: 192.168.56.10
    port: 6379
  session:
    store-type: redis

3.启动类添加配置
@EnableRedisHttpSession

4.登录接口，把登录信息存入session中
/**
 * 授权回调页
 *
 * @param code 根据code换取Access Token，且code只能兑换一次Access Token
 */
@GetMapping("/oauth2.0/weibo/success")
public String weibo(@RequestParam("code") String code, HttpSession session, HttpServletResponse servletResponse) throws Exception {
    // 1.根据code换取Access Token
    Map<String, String> headers = new HashMap<>();
    Map<String, String> querys = new HashMap<>();
    Map<String, String> map = new HashMap<>();
    map.put("client_id", "2129105835");
    map.put("client_secret", "201b8aa95794dbb6d52ff914fc8954dc");
    map.put("grant_type", "authorization_code");
    map.put("redirect_uri", "http://auth.gulimall.com/oauth2.0/weibo/success");
    map.put("code", code);
    HttpResponse response = HttpUtils.doPost("https://api.weibo.com", "/oauth2/access_token", headers, querys, map);

    // 2.处理请求返回
    if (response.getStatusLine().getStatusCode() == 200) {
        // 换取Access_Token成功
        String jsonString = EntityUtils.toString(response.getEntity());
        WBSocialUserVO user = JSONObject.parseObject(jsonString, WBSocialUserVO.class);

        // 首次登录自动注册（为当前社交登录用户生成一个会员账号信息，以后这个社交账户就会对应指定的会员）
        // 非首次登录则直接登录成功
        R r = memberAgentService.oauthLogin(user);
        if (r.getCode() == 0) {
            // 登录成功
            MemberResponseVO loginUser = r.getData(new TypeReference<MemberResponseVO>() {
            });
            log.info("登录成功：用户：{}", loginUser.toString());

            // 3.信息存储到session中，并且放大作用域（指定domain=父级域名）
            session.setAttribute(AuthConstant.LOGIN_USER, loginUser);
            // 首次使用session时，spring会自动颁发cookie设置domain，所以这里手动设置cookie很麻烦，采用springsession的方式颁发父级域名的domain权限
//                Cookie cookie = new Cookie("JSESSIONID", loginUser.getId().toString());
//                cookie.setDomain("gulimall.com");
//                servletResponse.addCookie(cookie);
            // 跳回首页
            return "redirect:http://gulimall.com";
        } else {
            // 登录失败，调回登录页
            return "redirect:http://auth.gulimall.com/login.html";
        }
    } else {
        // 换取Access_Token成功
        return "redirect:http://auth.gulimall.com/login.html";
    }
}

5.MemberResponseVO实现序列化接口
原理：内存中的对象要序列化成一个二进制流 传输到 redis中存储
public class MemberResponseVO implements Serializable

6.添加以下配置，放大作用域 + 指定redis序列化器【否则使用默认的jdk序列化器】
/**
 * springsession配置类
 */
@Configuration
public class GulimallSessionConfig {
    @Bean
    public CookieSerializer cookieSerializer() {
        DefaultCookieSerializer cookieSerializer = new DefaultCookieSerializer();
        cookieSerializer.setDomainName("gulimall.com");// 放大作用域
        cookieSerializer.setCookieName("GULISESSION");
        cookieSerializer.setCookieMaxAge(60 * 60 * 24 * 7);// 指定cookie有效期7天，会话级关闭浏览器后cookie即失效
        return cookieSerializer;
    }

    @Bean
    public RedisSerializer<Object> springSessionDefaultRedisSerializer() {
        // 指定session序列化到redis的序列化器
        return new GenericJackson2JsonRedisSerializer();
    }
}

7.修改product模块gulimall首页，去除session中的loginUser
<li>
  <a th:if="${session.loginUser != null}">欢迎, [[${session.loginUser.nickname}]]</a>
  <a th:if="${session.loginUser == null}" href="http://auth.gulimall.com/login.html">你好，请登录</a>
</li>

8.测试
=》进入auth.gulimall.com并社交登录
=》进入gulimall.com查看cookie作用域是否修改成功
=》查看redis，session是否存储成功
=》查看gulimall首页nickname是否取到值
```



**springsession文档页：**

![1638276069585](1638276069585.png)

#### springsession原理

```java
装饰者模式+自动续期

核心原理
1)、@EnablcRedisHttpSession导入RedisHttpSessionConfiguration配置
	1、给容器中添加了一个组件
		SessionRepository=》》》【RedisOperationsSessionRepository】=-》redis操作session。session的增删改查操作
	2、SessionRepositoryFiLter=:》Filter:session '存储过滤器;每个请求过来都必须经过filter
		1、创建的时侯，就自动从容器中获取到了sessionRepository;
		2、原始的request，response都被包装。SessionRepositoryRequestWrapper，														SessionRepositoryResponseWrapper
		3、以后获取session。 request.getSession();
		4、wrappedRequest.getSession(); 如果session中不存在，就到redis中查找
			SessionRepositort中获取到getById(xx)
2）、Spring Session 会给redis中的session数据自动延期

Spring Session核心方法：SessionRepositoryFilter过滤器
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {
        request.setAttribute(SESSION_REPOSITORY_ATTR, this.sessionRepository);
// 装饰者模式，包装request和response，然后将包装后的request和response对象放行
// 然后request和response被换成了SessionRepositoryRequestWrapper和SessionRepositoryResponseWrapper对象
        SessionRepositoryFilter<S>.SessionRepositoryRequestWrapper wrappedRequest = new SessionRepositoryFilter.SessionRepositoryRequestWrapper(request, response);
        SessionRepositoryFilter.SessionRepositoryResponseWrapper wrappedResponse = new SessionRepositoryFilter.SessionRepositoryResponseWrapper(wrappedRequest, response);

        try {
            filterChain.doFilter(wrappedRequest, wrappedResponse);
        } finally {
            wrappedRequest.commitSession();
        }

    }
```

### 6.6.网站的单点登录

```json
多个不同域名下，springsession无法共享

单点登录特性：非父子域名下共享登录状态
	一处退出，处处退出
	一处登录，处处登录
	
原理：
	1.客户端访问认证中心并带上回调url，进行登录
	2.登录成功认证中心域名下设置cookie，并跳转url?token=xxx，携带token参数
	3.客户端根据tokne请求认证中心获取用户信息【微博是用code获取AcsessToken，然后根据AcsessToken获取信息】
	4.客户端2再访问认证中心时，会带上浏览器存储的cookie，从而直接登录通过
```

![1638371742062](1638371742062.png)

**原理：**

![1638372384411](1638372384411.png)

#### 实例

```java
1.创建中央认证服务器模块
    <groupId>com.atguigu</groupId>
    <artifactId>gulimall-test-sso-server</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <name>gulimall-test-sso-server</name>
    <description>单点登录的认证服务器</description>

2.创建两个客户端
    <groupId>com.atguigu</groupId>
    <artifactId>gulimall-test-sso-client</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <name>gulimall-test-sso-client</name>
    <description>单点登录客户端</description>
    
    <groupId>com.atguigu</groupId>
    <artifactId>gulimall-test-sso-client2</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <name>gulimall-test-sso-client2</name>
    <description>单点登录客户端2</description>
    
3.修改本地host，添加三个域名
127.0.0.1 sso.com
127.0.0.1 client1.com
127.0.0.1 client2.com

4.sso认证接口
@Controller
public class LoginController {

    @Autowired
    StringRedisTemplate redisTemplate;

    @ResponseBody
    @GetMapping("/userinfo")
    public String userInfo(@RequestParam("token") String token) {
        String username = redisTemplate.opsForValue().get(token);
        return username;
    }

    /**
     * 访问登录页
     * @param url       登录成功回调页
     * @param sso_token cookie值
     */
    @GetMapping(value = "/login.html")
    public String login(@RequestParam("redirect_url") String url, Model model,
                        @CookieValue(value = "sso_token", required = false) String token) {
        // 根据token获取用户信息
        if (!StringUtils.isEmpty(token)) {
            String username = redisTemplate.opsForValue().get(token);
            if (!StringUtils.isEmpty(username)) {
                // token正确，已登录状态，跳转回客户端【当前访问客户端共享了其他客户端的登录状态】
                return "redirect:" + url + "?token=" + token;
            }
        }
        // 不存在sso_token，未登录返回登录页，并将回调地址链路下传
        model.addAttribute("url", url);
        return "login";
    }

    /**
     * 登录
     * @param url       登录成功回调页
     */
    @PostMapping(value = "/doLogin")
    public String doLogin(String username, String password, String url,
                          Model model, HttpServletResponse response) {
        if (!StringUtils.isEmpty(username) && !StringUtils.isEmpty(password)) {
            // 登录成功，跳转回调页
            String token = UUID.randomUUID().toString().replace("-", "");
            // token作为key，用户信息作为value存入redis中
            redisTemplate.opsForValue().set(token, username);
            // 在sso.com域名下设置cookie，使得不同客户端访问单点登录时可以带上cookie值成功登录
            Cookie cookie = new Cookie("sso_token", token);
            response.addCookie(cookie);
            return "redirect:" + url + "?token=" + token;
        }
        // 登录失败
        model.addAttribute("url", url);
        return "login";
    }

}

登录页面：
<!DOCTYPE html>
<html lang="en" xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <title>登录页</title>
</head>
<body>
<form action="/doLogin" method="post">
    用户名：<input type="text" name="username"/><br/>
    密码：<input type="password" name="password"/><br/>
    <input type="hidden" name="url" th:value="${url}">
    <input type="submit" value="登录">
</form>
</body>
</html>

5.客户端接口
@Controller
public class HelloController {

    /**
     * 需要登录状态访问
     */
    @GetMapping(value = "/employees")
    public String employees(Model model, HttpSession session,
                            @RequestParam(name = "token", required = false) String token) {
        if (!StringUtils.isEmpty(token)) {
            // 根据token去sso认证中心获取用户信息
            RestTemplate restTemplate = new RestTemplate();
            ResponseEntity<String> entity = restTemplate.getForEntity("http://sso.com:8080/userinfo?token=" + token, String.class);
            session.setAttribute("loginUser", entity.getBody());
        }
        Object loginUser = session.getAttribute("loginUser");
        if (loginUser == null && token == null) {
            // 未登录,跳转认证服务器登录
            return "redirect:http://sso.com:8080/login.html?redirect_url=http://client2.com:8082/employees";
        } else {
            // 登录状态显示
            List<String> emps = new ArrayList<>();
            emps.add("张三");
            emps.add("李四");
            model.addAttribute("emps", emps);
            return "employees";
        }

    }
}

<!DOCTYPE html>
<html lang="en" xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <title>员工列表</title>
</head>
<body>
<h1>欢迎：[[${session.loginUser}]]</h1>
<ul>
    <li th:each="emp:${emps}">姓名：[[${emp}]]</li>
</ul>
</body>
</html>
```

**认证服务器：**

![1638372530176](1638372530176.png)

![1638374476981](1638374476981.png)

# 七、购物车（redis实现）

## 1.游客购物车（京东取消了）

```json
1.未登录状态下加入购物车的商品
2.关闭浏览器后再打开，商品仍然存在
3.采用redis【很好的高并发性能，强于MongoDB】

4.使用user-key【相当于UUID，存在于cookie中】成为临时用户
【如果没有user-key，第一次访问购物车时，会自动分配一个user-key（临时用户身份）】

逻辑：
	1）第一次使用购物车功能，创建user-key（分配临时用户身份）
	2）访问购物车时，判断当前是否登录状态（session是否存在用户信息）
		登录状态则获取用户购物车信息
	3）未登录状态，则获取临时用户身份，获取游客购物车
```

## 2.用户购物车

```json
1.会将游客状态下的购物车，整合到登录用户名下的购物车
2.游客购物车被清空（此时退出登录游客购物车已被清空）
3.采用redis

因为要获取用户登录状态，所以需要整合springsession
```

## 3.环境搭建

```json
1.搭建模块
name：gulimall-cart
group：com.atguigu
Artifact：gulimall-cart
Package Name：com.atguigu.gulimall.cart

2.上传静态资源到nginx上
/mydata/nginx/html/static/cart

3.配置网关
- id: gulimall_cart_route
  uri: lb://gulimall-cart
  predicates:
    - Host=cart.gulimall.com

4.配置DNS
# gulimall
192.168.56.10 gulimall.com
192.168.56.10 search.gulimall.com
192.168.56.10 item.gulimall.com
192.168.56.10 auth.gulimall.com
192.168.56.10 cart.gulimall.com

5.新增依赖
<!--公共模块-->
<dependency>
    <groupId>com.atguigu.gulimall</groupId>
    <artifactId>gulimall-common</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <exclusions>
        <exclusion>
            <groupId>com.baomidou</groupId>
            <artifactId>mybatis-plus-boot-starter</artifactId>
        </exclusion>
    </exclusions>
</dependency>
<!--redis-->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-redis</artifactId>
</dependency>

6.添加redis配置
spring.redis.host=192.168.56.10
spring.redis.port=6379

7.启动类增加注解
@EnableRedisHttpSession
@EnableFeignClients
@EnableDiscoveryClient
@SpringBootApplication
public class GulimallCartApplication {

    public static void main(String[] args) {
        SpringApplication.run(GulimallCartApplication.class, args);
    }

}

8.springsession配置类
/**
 * springsession配置类
 * @Author: wanzenghui
 * @Date: 2021/11/30 22:21
 */
@Configuration
public class GulimallSessionConfig {
    @Bean
    public CookieSerializer cookieSerializer() {
        DefaultCookieSerializer cookieSerializer = new DefaultCookieSerializer();
        cookieSerializer.setDomainName("gulimall.com");// 放大作用域
        cookieSerializer.setCookieName("GULISESSION");
        cookieSerializer.setCookieMaxAge(60 * 60 * 24 * 7);// 指定cookie有效期7天，会话级关闭浏览器后cookie即失效
        return cookieSerializer;
    }

    @Bean
    public RedisSerializer<Object> springSessionDefaultRedisSerializer() {
        // 指定session序列化到redis的序列化器
        return new GenericJackson2JsonRedisSerializer();
    }
}
```

 ![1638538698140](1638538698140.png)

 ![1638538911798](1638538911798.png)

## 4.购物车数据结构与VO

**购物车商品列表截图：**

![1638631056625](1638631056625.png)

**数据结构：**

![1638546401758](1638546401758.png)

```json
Map<String k1, Map<String k2, CartItemInfo>>

key：用户标示
	登录态：gulimall:cart:userId
	非登录态：gulimall:cart:userKey

value：
	存储一个Hash结构的值，其中该hash结构的key是SkuId，hash结构的value是商品信息，以json字符串格式存储
```

**购物车VO**：

```java
/**
 * 购物车VO
 * 需要计算的属性需要重写get方法，保证每次获取属性都会进行计算
 */
public class CartVO {

    private List<CartItemVO> items; // 购物项集合
    private Integer countNum;       // 商品件数（汇总购物车内商品总件数）
    private Integer countType;      // 商品数量（汇总购物车内商品总个数）
    private BigDecimal totalAmount; // 商品总价
    private BigDecimal reduce = new BigDecimal("0.00");// 减免价格

    public List<CartItemVO> getItems() {
        return items;
    }

    public void setItems(List<CartItemVO> items) {
        this.items = items;
    }

    public Integer getCountNum() {
        int count = 0;
        if (items != null && items.size() > 0) {
            for (CartItemVO item : items) {
                count += item.getCount();
            }
        }
        return count;
    }

    public Integer getCountType() {
        return CollectionUtils.isEmpty(items) ? 0 : items.size();
    }


    public BigDecimal getTotalAmount() {
        BigDecimal amount = new BigDecimal("0");
        // 1、计算购物项总价
        if (!CollectionUtils.isEmpty(items)) {
            for (CartItemVO cartItem : items) {
                if (cartItem.getCheck()) {
                    amount = amount.add(cartItem.getTotalPrice());
                }
            }
        }
        // 2、计算优惠后的价格
        return amount.subtract(getReduce());
    }

    public BigDecimal getReduce() {
        return reduce;
    }

    public void setReduce(BigDecimal reduce) {
        this.reduce = reduce;
    }
}

/**
 * 购物项VO（购物车内每一项商品内容）
 */
public class CartItemVO {
    private Long skuId;                     // skuId
    private Boolean check = true;           // 是否选中
    private String title;                   // 标题
    private String image;                   // 图片
    private List<String> skuAttrValues;     // 销售属性
    private BigDecimal price;               // 单价
    private Integer count;                  // 商品件数
    private BigDecimal totalPrice;          // 总价

    public Long getSkuId() {
        return skuId;
    }

    public void setSkuId(Long skuId) {
        this.skuId = skuId;
    }

    public Boolean getCheck() {
        return check;
    }

    public void setCheck(Boolean check) {
        this.check = check;
    }

    public String getTitle() {
        return title;
    }

    public void setTitle(String title) {
        this.title = title;
    }

    public String getImage() {
        return image;
    }

    public void setImage(String image) {
        this.image = image;
    }

    public List<String> getSkuAttrValues() {
        return skuAttrValues;
    }

    public void setSkuAttrValues(List<String> skuAttrValues) {
        this.skuAttrValues = skuAttrValues;
    }

    public BigDecimal getPrice() {
        return price;
    }

    public void setPrice(BigDecimal price) {
        this.price = price;
    }

    public Integer getCount() {
        return count;
    }

    public void setCount(Integer count) {
        this.count = count;
    }

    /**
     * 计算当前购物项总价
     */
    public BigDecimal getTotalPrice() {
        return this.price.multiply(new BigDecimal("" + this.count));
    }

    public void setTotalPrice(BigDecimal totalPrice) {
        this.totalPrice = totalPrice;
    }
}
```

## 5.拦截器

```json
业务逻辑：
	1）第一次使用购物车功能，创建user-key（分配临时用户身份）
	2）访问购物车时，判断当前是否登录状态（session是否存在用户信息）
		登录状态则获取用户购物车信息
	3）未登录状态，则获取临时用户身份，获取游客购物车

拦截器功能：
	过滤器（URL拦截）=》拦截器（URL拦截）=》切面（方法拦截）
	1.preHandle
		1）获取用户登录信息userId，封装到ThreadLocal中，controller可以拿到
		2）用户未登录，分配userKey封装到ThreadLocal中，controller可以拿到
	
	2.postHandle
		1）判断客户端是否存在游客用户标识
		不存在则创建cookie，命令客户端保存游客信息user-key
```

### ThreadLocal共享登录用户信息

![1638715492156](1638715492156.png)

```java
public class CartInterceptor implements HandlerInterceptor {

    public static ThreadLocal<UserInfoTO> threadLocal = new ThreadLocal<>();

    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        // 获取会话信息，获取登录用户信息
        HttpSession session = request.getSession();
        MemberResponseVO attribute = (MemberResponseVO) session.getAttribute(AuthConstant.LOGIN_USER);
        // 判断是否登录，并封装User对象给controller使用
        UserInfoTO user = new UserInfoTO();
        if (attribute != null) {
            // 登录状态，封装用户ID，供controller使用
            user.setUserId(attribute.getId());
        }
        // 获取当前请求游客用户标识user-key
        Cookie[] cookies = request.getCookies();
        if (ArrayUtils.isNotEmpty(cookies)) {
            for (Cookie cookie : cookies) {
                if (cookie.getName().equals(CartConstant.TEMP_USER_COOKIE_NAME)) {
                    // 获取user-key值封装到user，供controller使用
                    user.setUserKey(cookie.getValue());
                    user.setTempUser(true);// 不需要重新分配
                    break;
                }
            }
        }

        // 判断当前是否存在游客用户标识
        if (StringUtils.isBlank(user.getUserKey())) {
            // 无游客标识，分配游客标识
            user.setUserKey(UUID.randomUUID().toString());
        }

        // 封装用户信息（登录状态userId非空，游客状态userId空）
        threadLocal.set(user);
        return true;
    }

    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {
        UserInfoTO user = threadLocal.get();
        if (user != null && !user.isTempUser()) {
            // 需要为客户端分配游客信息
            Cookie cookie = new Cookie(CartConstant.TEMP_USER_COOKIE_NAME, user.getUserKey());
            cookie.setDomain("gulimall.com");// 作用域
            cookie.setMaxAge(CartConstant.TEMP_USER_COOKIE_TIMEOUT);// 过期时间
            response.addCookie(cookie);
        }
    }
}
```



## 6.接口API

### 6.1.添加商品到购物车

![1638798154194](1638798154194.png)

```java
商品详情页（gulimall-product），点击添加购物车， 跳转（gulimall-cart）success.html
```

```java
/**
 * 添加商品到购物车
 * @param skuId 商品ID
 * @param num   商品数量
 * @param attributes    重定向数据域
 */
@GetMapping(value = "/addCartItem")
public String addCartItem(@RequestParam("skuId") Long skuId,
                          @RequestParam("num") Integer num,
                          RedirectAttributes attributes) throws ExecutionException, InterruptedException {
    // 添加sku商品到购物车
    cartService.addToCart(skuId, num);
    attributes.addAttribute("skuId", skuId);// 会在url后面拼接参数
    // 请求重定向给addToCartSuccessPage.html，防刷
    return "redirect:http://cart.gulimall.com/addToCartSuccessPage.html";
}
```

```java
/**
 * 添加sku商品到购物车
 */
@Override
public CartItemVO addToCart(Long skuId, Integer num) throws ExecutionException, InterruptedException {
    // 获取购物车redis操作对象
    BoundHashOperations<String, Object, Object> operations = getCartOps();
    // 获取商品
    String cartItemJSONString = (String) operations.get(skuId.toString());
    if (StringUtils.isEmpty(cartItemJSONString)) {
        // 购物车不存在此商品，需要将当前商品添加到购物车中
        CartItemVO cartItem = new CartItemVO();
        CompletableFuture<Void> getSkuInfoFuture = CompletableFuture.runAsync(() -> {
            // 远程查询当前商品信息
            R r = productFeignService.getInfo(skuId);
            SkuInfoVO skuInfo = r.getData("skuInfo", new TypeReference<SkuInfoVO>() {
            });
            cartItem.setSkuId(skuInfo.getSkuId());// 商品ID
            cartItem.setTitle(skuInfo.getSkuTitle());// 商品标题
            cartItem.setImage(skuInfo.getSkuDefaultImg());// 商品默认图片
            cartItem.setPrice(skuInfo.getPrice());// 商品单价
            cartItem.setCount(num);// 商品件数
            cartItem.setCheck(true);// 是否选中
        }, executor);

        CompletableFuture<Void> getSkuAttrValuesFuture = CompletableFuture.runAsync(() -> {
            // 远程查询attrName:attrValue信息
            List<String> skuSaleAttrValues = productFeignService.getSkuSaleAttrValues(skuId);
            cartItem.setSkuAttrValues(skuSaleAttrValues);
        }, executor);

        CompletableFuture.allOf(getSkuInfoFuture, getSkuAttrValuesFuture).get();
        operations.put(skuId.toString(), JSON.toJSONString(cartItem));
        return cartItem;
    } else {
        // 当前购物车已存在此商品，修改当前商品数量
        CartItemVO cartItem = JSON.parseObject(cartItemJSONString, CartItemVO.class);
        cartItem.setCount(cartItem.getCount() + num);
        operations.put(skuId.toString(), JSON.toJSONString(cartItem));
        return cartItem;
    }
}
```

#### Hash数据类型操作对象

```java
/**
 * 根据用户信息获取购物车redis操作对象
 */
private BoundHashOperations<String, Object, Object> getCartOps() {
    // 获取用户登录信息
    UserInfoTO userInfo = CartInterceptor.threadLocal.get();
    String cartKey = "";
    if (userInfo.getUserId() != null) {
        // 登录态，使用用户购物车
        cartKey = CartConstant.CART_PREFIX + userInfo.getUserId();
    } else {
        // 非登录态，使用游客购物车
        cartKey = CartConstant.CART_PREFIX + userInfo.getUserKey();
    }
    // 绑定购物车的key操作Redis
    BoundHashOperations<String, Object, Object> operations = redisTemplate.boundHashOps(cartKey);
    return operations;
}
```

#### 接口防刷

![1638889646356](1638889646356.png)

```json
如果刷新cart.gulimall.com/addToCart?skuId=7&num=1该页面，会导致购物车中此商品的数量无限新增
解决方案：
	/addToCart请求使用重定向给/addToCartSuccessPage.html
	由/addToCartSuccessPage.html这个请求跳转"商品已成功加入购物车页面"（浏览器url请求已更改），达到防刷的目的
```

```java
/**
 * 商品添加购物车成功页（防刷）
 */
@GetMapping(value = "/addToCartSuccessPage.html")
public String addToCartSuccessPage(@RequestParam("skuId") Long skuId, Model model) {
    //重定向到成功页面。再次查询购物车数据即可
    CartItemVO cartItemVo = cartService.getCartItem(skuId);
    model.addAttribute("cartItem",cartItemVo);
    return "success";
}

/**
 * 根据skuId获取购物车商品信息
 */
@Override
public CartItemVO getCartItem(Long skuId) {
    // 获取购物车redis操作对象
    BoundHashOperations<String, Object, Object> cartOps = getCartOps();
    String cartItemJSONString = (String) cartOps.get(skuId.toString());
    CartItemVO cartItemVo = JSON.parseObject(cartItemJSONString, CartItemVO.class);
    return cartItemVo;
}
```

**达到防刷目的的重定向请求：**

![1638891386942](1638891386942.png)

### 6.2.购物车列表

![1638631056625](1638631056625.png)

```java
/**
 * 购物车列表页
 * 1.拦截器封装用户信息
 * 1）已登录状态：封装userId+userKey到ThreadLocal中
 * 2）未登录状态：
 * 2-1）已分配游客标识，封装userKey到ThreadLocal中
 * 2-2）未分配游客标识，命令客户端保存cookie（user-key），并封装userKey到ThreadLocal中
 * 2.根据用户标识获取购物车信息
 * 1）已登录状态
 * 使用userId作为key获取购物车
 * 使用userKey作为key获取游客购物车，如果非空则与用户购物车合并
 * 2）未登录状态
 * 使用userKey作为key获取游客购物车
 * 3.返回cartList列表页
 */
@GetMapping("/cart.html")
public String cartListPage(Model model) throws ExecutionException, InterruptedException {
    CartVO cartVO = cartService.getCart();
    model.addAttribute("cart", cartVO);
    return "cartList";
}
```

```java
/**
 * 购物车列表
 */
@Override
public CartVO getCart() throws ExecutionException, InterruptedException {
    CartVO cart = new CartVO();
    // 获取用户登录信息
    UserInfoTO userInfo = CartInterceptor.threadLocal.get();
    // 获取游客购物车
    List<CartItemVO> touristItems = getCartItems(CartConstant.CART_PREFIX + userInfo.getUserKey());
    if (userInfo.getUserId() != null) {
        // 登录状态
        if (!CollectionUtils.isEmpty(touristItems)) {
            // 游客购物车非空，需要整合到用户购物车
            for (CartItemVO item : touristItems) {
                // 将商品逐个放到用户购物车
                addToCart(item.getSkuId(), item.getCount());
            }
            // 清楚游客购物车
            clearCart(CartConstant.CART_PREFIX + userInfo.getUserKey());
        }
        // 获取用户购物车（已经合并后的购物车）
        List<CartItemVO> items = getCartItems(CartConstant.CART_PREFIX + userInfo.getUserId());
        cart.setItems(items);
    } else {
        // 未登录状态，返回游客购物车
        cart.setItems(touristItems);
    }
    return cart;
}

/**
 * 根据购物车的key获取
 */
private List<CartItemVO> getCartItems(String cartKey) {
    BoundHashOperations<String, Object, Object> operations = redisTemplate.boundHashOps(cartKey);
    List<Object> values = operations.values();
    if (!CollectionUtils.isEmpty(values)) {
        // 购物车非空，反序列化成商品并封装成集合返回
        return values.stream()
                .map(jsonString -> JSONObject.parseObject((String) jsonString, CartItemVO.class))
                .collect(Collectors.toList());
    }
    return null;
}

/**
 * 清空购物车
 */
@Override
public void clearCart(String cartKey) {
    redisTemplate.delete(cartKey);
}
```

### 6.3.更改购物车商品选中状态

![1638977355938](1638977355938.png)

```java
/**
 * 更改购物车商品选中状态
 */
@GetMapping(value = "/checkItem")
public String checkItem(@RequestParam(value = "skuId") Long skuId,
                        @RequestParam(value = "checked") Integer check) {
    cartService.checkItem(skuId, check);
    return "redirect:http://cart.gulimall.com/cart.html";
}

/**
 * 更改购物车商品选中状态
 */
@Override
public void checkItem(Long skuId, Integer check) {
    // 查询购物车商品信息
    CartItemVO cartItem = getCartItem(skuId);
    // 修改商品选中状态
    cartItem.setCheck(ObjectConstant.BooleanIntEnum.YES.getCode().equals(check) ? true : false);
    // 更新到redis中
    BoundHashOperations<String, Object, Object> cartOps = getCartOps();
    cartOps.put(skuId.toString(), JSONObject.toJSONStringWithDateFormat(cartItem, DateUtils.DATATIMEF_TIME_STR));
}
```

### 6.4.更改商品数量

![1638977915027](1638977915027.png)

```java
/**
 * 改变商品数量
 */
@GetMapping(value = "/countItem")
public String countItem(@RequestParam(value = "skuId") Long skuId,
                        @RequestParam(value = "num") Integer num) {
    cartService.changeItemCount(skuId,num);
    return "redirect:http://cart.gulimall.com/cart.html";
}

/**
 * 改变商品数量
 */
@Override
public void changeItemCount(Long skuId, Integer num) {
    // 查询购物车商品信息
    CartItemVO cartItem = getCartItem(skuId);
    // 修改商品数量
    cartItem.setCount(num);
    // 更新到redis中
    BoundHashOperations<String, Object, Object> cartOps = getCartOps();
    cartOps.put(skuId.toString(), JSONObject.toJSONStringWithDateFormat(cartItem, DateUtils.DATATIMEF_TIME_STR));
}
```

### 6.5.删除购物车商品

![1638978012891](1638978012891.png)

```java
/**
 * 删除商品信息
 */
@GetMapping(value = "/deleteItem")
public String deleteItem(@RequestParam("skuId") Integer skuId) {
    cartService.deleteIdCartInfo(skuId);
    return "redirect:http://cart.gulimall.com/cart.html";
}

/**
 * 删除购物项
 */
@Override
public void deleteIdCartInfo(Integer skuId) {
    BoundHashOperations<String, Object, Object> operations = getCartOps();
    operations.delete(skuId.toString());
}
```

### 6.6.购物车列表页选中商品

![1639915866386](1639915866386.png)

```java
注意：
    1、全局异常处理的原理
    2、需求解析：购物车列表页选中指定商品获取商品价格信息
```

```java
/**
 * 获取当前用户的购物车所有商品项
 * 订单服务调用：【购物车列表页面点击确认订单时】
 * 从redis中获取所有选中的商品项
 * 并且要获取最新的商品价格信息，替换redis中的价格信息
 */
@GetMapping(value = "/currentUserCartItems")
@ResponseBody
public List<CartItemVO> getCurrentCartItems() {
    List<CartItemVO> cartItemVoList = cartService.getUserCartItems();
    return cartItemVoList;
}

/**
 * 获取购物车，最新价格
 */
@Override
public List<CartItemVO> getUserCartItems() {
    List<CartItemVO> cartItemVoList = new ArrayList<>();
    // 获取当前用户登录的信息
    UserInfoTO userInfo = CartInterceptor.threadLocal.get();
    if (userInfo.getUserId() == null) {
        // 未登录
        return null;
    } else {
        // 已登录，获取用户购物车
        List<CartItemVO> items = getCartItems(CartConstant.CART_PREFIX + userInfo.getUserId());
        if (CollectionUtils.isEmpty(items)) {
            throw new CartExceptionHandler();
        }
        // 筛选所有选中的sku
        Map<Long, CartItemVO> itemMap = items.stream().filter(item -> item.getCheck())
                .collect(Collectors.toMap(CartItemVO::getSkuId, val -> val));
        // 调用远程获取最新价格
        Map<Long, BigDecimal> priceMap = productFeignService.getPrice(itemMap.keySet());
        // 封装价格返回
        items = itemMap.entrySet().stream().map(entry -> {
            CartItemVO item = entry.getValue();
            item.setPrice(priceMap.get(entry.getKey()));
            return item;
        }).collect(Collectors.toList());
        return items;
    }
}
```

# 八、订单模块

## 1.环境搭建

### 1.1.整合环境

**等待付款（订单详情页）：**

![1639917168387](/assert/1639917168387.png)

**订单页（订单确认页）：**

![1639917240515](/assert/1639917240515.png)

**结算页：**

![1639917304803](/assert/1639917304803.png)

![1639917273523](/assert/1639917273523.png)

![1639917336553](/assert/1639917336553.png)
**收银页：**

![1639917432819](/assert/1639917432819.png)

 ![1639917446662](/assert/1639917446662.png)


```shell
1.拷贝静态资源到nginx中，html页面的请求资源修改为/static/order/xxx开头
	1）等待付款（订单详情页）
		静态资源拷贝=》/mydata/nginx/html/static/order/detail
		html文件拷贝至order模块，更名为detail.html
	2）订单页（订单列表、订单确认收货页）
		静态资源拷贝=》/mydata/nginx/html/static/order/list
		html文件拷贝至order模块，更名为list.html
	3）结算页（订单提交页）
		静态资源拷贝=》/mydata/nginx/html/static/order/confirm
		html文件拷贝至order模块，更名为confirm.html
	4）收银页（收银台、选择支付方式）
		静态资源拷贝=》/mydata/nginx/html/static/order/pay
		html文件拷贝至order模块，更名为pay.html

2.本地DNS解析配置域名
# gulimall
192.168.56.10 gulimall.com
192.168.56.10 search.gulimall.com
192.168.56.10 item.gulimall.com
192.168.56.10 auth.gulimall.com
192.168.56.10 cart.gulimall.com
192.168.56.10 order.gulimall.com

3.配置好nginx转发规则（前面配置其他模块的时候已经配置）
	静态资源请求：/usr/share/nginx/html（已经映射上了/mydata/nginx/html）
	动态资源请求：转发至192.168.56.1:88（网关）

4.配置网关转发
        - id: gulimall_order_route
          uri: lb://gulimall-order
          predicates:
            - Host=order.gulimall.com

5.引入thymeleaf依赖，并在开发期间禁用缓存
        <!--thymeleaf模板引擎-->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-thymeleaf</artifactId>
        </dependency>
        
6.启动类
// 开启rabbit
@EnableRabbit
// 开启SpringSession
@EnableRedisHttpSession
// 开启服务注册功能
@EnableDiscoveryClient
@MapperScan("com.atguigu.gulimall.order.dao")
@SpringBootApplication
public class GulimallOrderApplication {

    public static void main(String[] args) {
        SpringApplication.run(GulimallOrderApplication.class, args);
    }

}
```

```yml
7.配置：
server:
  port: 9000

spring:
  application:
    name: gulimall-order
  cloud:
    nacos:
      discovery:
        server-addr: 127.0.0.1:8848
  # 开发期间禁用缓存
  thymeleaf:
    cache: false
```

### 1.2.整合springsession

```json
1.在各服务添加springsession依赖（服务自治）【auth、product、search、member、order、】
<!--redis-->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-redis</artifactId>
</dependency>
<!--整合springsession，实现session共享-->
<dependency>
    <groupId>org.springframework.session</groupId>
    <artifactId>spring-session-data-redis</artifactId>
</dependency>

2.属性配置
server:
  servlet:
    session:
      timeout: 30m
spring:
  redis:
    host: 192.168.56.10
    port: 6379
  session:
    store-type: redis

3.启动类添加配置
@EnableRedisHttpSession


6.添加以下配置，放大作用域 + 指定redis序列化器【否则使用默认的jdk序列化器】
/**
 * springsession配置类
 */
@Configuration
public class GulimallSessionConfig {
    @Bean
    public CookieSerializer cookieSerializer() {
        DefaultCookieSerializer cookieSerializer = new DefaultCookieSerializer();
        cookieSerializer.setDomainName("gulimall.com");// 放大作用域
        cookieSerializer.setCookieName("GULISESSION");
        cookieSerializer.setCookieMaxAge(60 * 60 * 24 * 7);// 指定cookie有效期7天，会话级关闭浏览器后cookie即失效
        return cookieSerializer;
    }

    @Bean
    public RedisSerializer<Object> springSessionDefaultRedisSerializer() {
        // 指定session序列化到redis的序列化器
        return new GenericJackson2JsonRedisSerializer();
    }
}

7.修改product模块gulimall首页，去除session中的loginUser
<li>
  <a th:if="${session.loginUser != null}">欢迎, [[${session.loginUser.nickname}]]</a>
  <a th:if="${session.loginUser == null}" href="http://auth.gulimall.com/login.html">你好，请登录</a>
</li>

8.测试
=》进入auth.gulimall.com并社交登录
=》进入gulimall.com查看cookie作用域是否修改成功
=》查看redis，session是否存储成功
=》查看gulimall首页nickname是否取到值
```

### 1.3.整合线程池

```java
@EnableConfigurationProperties(MyThreadConfig.ThreadPoolConfigProperties.class)
@Configuration
public class MyThreadConfig {
    @Bean
    public ThreadPoolExecutor threadPoolExecutor(ThreadPoolConfigProperties pool) {
        return new ThreadPoolExecutor(
                pool.getCoreSize(),
                pool.getMaxSize(),
                pool.getKeepAliveTime(),
                TimeUnit.SECONDS,
                new LinkedBlockingDeque<>(100000),
                Executors.defaultThreadFactory(),
                new ThreadPoolExecutor.CallerRunsPolicy()
        );
    }

    @ConfigurationProperties(prefix = "gulimall.thread")
    @Data
    public class ThreadPoolConfigProperties {
        private Integer coreSize;
        private Integer maxSize;
        private Integer keepAliveTime;
    }
}
```

```yml
gulimall:
  thread:
    core-size: 20
    max-size: 200
    keep-alive-time: 10
```

### 1.4.application.yml

```yml
server:
  port: 9000
  servlet:
    session:
      timeout: 30m

spring:
  application:
    name: gulimall-order
  cloud:
    nacos:
      discovery:
        server-addr: 127.0.0.1:8848
  datasource:
    username: root
    password: root
    url: jdbc:mysql://192.168.56.10:3306/gulimall_oms?useUnicode=true&characterEncoding=UTF-8&useSSL=false&serverTimezone=Asia/Shanghai
    driver-class-name: com.mysql.cj.jdbc.Driver
  jackson:
    date-format: yyyy-MM-dd HH:mm:ss
    time-zone: GMT+8
  redis:
    host: 192.168.56.10
    port: 6379
  session:
    store-type: redis
  rabbitmq:
    host: 192.168.56.10
    port: 5672
    # 虚拟主机
    virtual-host: /
    # 开启发送端发送确认，无论是否到达broker都会触发回调【发送端确认机制+本地事务表】
    publisher-confirm-type: correlated
    # 开启发送端抵达队列确认，消息未被队列接收时触发回调【发送端确认机制+本地事务表】
    publisher-returns: true
    # 消息在没有被队列接收时是否强行退回
    template:
      mandatory: true
    # 消费者手动确认模式，关闭自动确认，否则会消息丢失
    listener:
      simple:
        acknowledge-mode: manual
  # 开发期间禁用缓存
  thymeleaf:
    cache: false

mybatis-plus:
  # 扫描依赖的jar包下的所有mapper.xml
  mapper-locations: classpath:/mapper/**/*.xml
  global-config:
    db-config:
      id-type: auto

gulimall:
  thread:
    core-size: 20
    max-size: 200
    keep-alive-time: 10
    
logging:
  level:
    com.atguigu.gulimall: debug
```

## 2.订单服务拆析

### 2.1.构成

```
电商系统涉及到3流，分别是信息流，资金流，物流，而订单系统作为中枢将三者有机的集合起来。
	三流：
		1、信息流：商品信息、优惠信息
		2、资金流：退款、付款
		3、物流：发送、退货
		
订单模块是电商系统的枢纽，在订单这个环节上需求获取多个模块的数据和信息，同时对这些信息进行加工处理后流向下个环节，这一系列就构成了订单的信息流通。
```

![1598670397820](/assert/1598670397820.png)

### 2.2.状态

```json
1、代付款
	用户提交订单后，订单进行预下单，目前主流电商网站都会唤起支付，便于用户快速完成支付，需要注意的是待付款状态下可以对库存进行锁定，锁定库存需要配置支付超时时间，超时后将自动取消订单，订单变更关闭状态。

2、已付款/待发货
	用户完成订单支付，订单系统需要记录支付时间，支付流水单号便于对账，订单下放到WMS系统，仓库进行调拨，配货，分拣，出库等操作。

3、待收货/已发货
	仓储将商品出库后，订单进入物流环节，订单系统需要同步物流信息，便于用户实时知悉物品物流状态

4、已完成
	用尸确认收员后，订单交易完成。后续支付侧进行结算，如果订单存在问题进入售后状态

5、已取消
	付款之前取消订单。包括超时未付款或用户商户取消订单都会产生这种订单状态。
	
6.售后中
	用户在付款后申请退款，或商家发货后用户申请退换货。售后也同样存在各种状态，当发起售后申请后生成售后订单，售后订单状态为待审核，等待商家审核，商家审核通过后订单状态变更为待退货，等待用户将商品寄回，商家收货后订单状态更新为待退款状态，退款到用户原账户后订单状态更新为售后成功。

```

### 2.3.订单流程

```json
	订单流程是指从订单产生到完成整个流转的过程，从而行程了一套标准流程规则。而不同的产品类型或业务类型在系统中的流程会千差万别，比如上面提到的线上实物订单和虚拟订单的流程，线上实物订单与o20订单等，所以需要根据不同的类型进行构建订单流程。不管类型如何订单都包括正向流程和逆向流程，对应的场景就是购买商品和退换货流程，正向流程就是一个正常的网购步骤，订单生成->支付订单->卖家发货-→>确认收货->交易成功。而每个步骤的背后，订单是如何在多系统之间交互流转的，可概括如下图

1、订单创建与支付
1)、订单创建前需要预览订单，选择收货信息等
(2)、订单创建需要锁定库存，库存有才可创建，否则不能创建
(3)、订单创建后超时未支付需要解锁库存
(4)、支付成功后，需要进行拆单，根据商品打包方式，所在仓库，物流等进行拆单
(5)、支付的每笔流水都需要记录，以待查账
(6)、订单创建，支付成功等状态都需要给MQ发送消息，方便其他系统感知订阅

2、逆向流程
(1)、修改订单，用户没有提交订单，可以对订单一些信息进行修改，比如配送信息，
优惠信息，及其他一些订单可修改范围的内容，此时只需对数据进行变更即可。
(2)、订单取消，用户主动取消订单和用户超时未支付，两种情况下订单都会取消订
单，而超时情况是系统自动关闭订单，所以在订单支付的响应机制上面要做支付的
```

![1598670706087](/assert/1598670706087.png)

## 3.登录拦截器

```json
订单模块需要用户登录后操作

步骤：
	1.添加拦截器
	2.添加配置使拦截器生效
```

```java
@Configuration
public class GulimallWebConfig implements WebMvcConfigurer {

    @Autowired
    private LoginUserInterceptor loginUserInterceptor;

    /**
     * 配置拦截器生效
     */
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(loginUserInterceptor).addPathPatterns("/**");// 访问任何订单请求需要拦截校验登录
    }
}


@Component
public class LoginUserInterceptor implements HandlerInterceptor {

    public static ThreadLocal<MemberResponseVO> threadLocal = new ThreadLocal<>();

    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        // TODO 待解释
        String uri = request.getRequestURI();
        AntPathMatcher antPathMatcher = new AntPathMatcher();
        boolean match = antPathMatcher.match("/order/order/status/**", uri);
        boolean match1 = antPathMatcher.match("/payed/notify", uri);
        if (match || match1) {
            return true;
        }

        // 获取登录用户信息
        MemberResponseVO attribute = (MemberResponseVO) request.getSession().getAttribute(AuthConstant.LOGIN_USER);
        if (attribute != null) {
            // 已登录，放行
            // 封装用户信息到threadLocal
            threadLocal.set(attribute);
            return true;
        } else {
            // 未登录，跳转登录页面
            response.setContentType("text/html;charset=UTF-8");
            PrintWriter out = response.getWriter();
            out.println("<script>alert('请先进行登录，再进行后续操作！');location.href='http://auth.gulimall.com/login.html'</script>");
            return false;
        }
    }
}
```



## 4.结算页（由购物车页跳转）

```json
购物车商品列表页，点击去结算跳转结算页：根据页面所选商品查询商品相关信息返回（金额、优惠等等）
```

**购物车页：**

![1640008626218](/assert/1640008626218.png)

**结算页：**

![1640008658115](/assert/1640008658115.png)

![1640609691863](/assert/1640609691863.png)

### bug1_feign丢失登录状态

![1640617649625](/assert/1640617649625.png)

![1640616541763](/assert/1640616541763.png)

```json
原因：
	浏览器请求时会带上Cookie: GULISESSION
	默认使用feign调用时，会根据拦截器构造请求参数RequestTemplate，而此时请求头没有带上Cookie，导致springsession无法获取用户信息

解决：
	拦截器构造请求头
```

```java
/**
 * feign配置类
 **/
@Configuration
public class GuliFeignConfig {

    /**
     * 注入拦截器
     * feign调用时根据拦截器构造请求头，封装cookie解决远程调用时无法获取springsession
     */
    @Bean("requestInterceptor")
    public RequestInterceptor requestInterceptor() {
        // 创建拦截器
        return new RequestInterceptor() {
            @Override
            public void apply(RequestTemplate template) {
                System.out.println("feign远程调用，拦截器封装请求头...RequestInterceptor.apply");
                // 1、使用RequestContextHolder拿到原生请求的请求头信（上下文环境保持器）
                // 从ThreadLocal中获取请求头（要保证feign调用与controller请求处在同一线程环境）
                ServletRequestAttributes requestAttributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();
                if (requestAttributes != null) {
                    HttpServletRequest request = requestAttributes.getRequest();// 获取controller请求对象
                    if (request != null) {
                        //2、同步请求头的数据（cookie）
                        String cookie = request.getHeader("Cookie");// 获取Cookie
                        template.header("Cookie", cookie);// 同步Cookie
                    }
                }
            }
        };
    }
}
```

### bug2_异步丢失登录状态

![1640650853893](/assert/1640650853893.png)

```json
原因：
	使用异步编排时，非同一线程无法取到RequestContextHolder（上下文环境保持器）
ServletRequestAttributes requestAttributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();
HttpServletRequest request = requestAttributes.getRequest();// 获取controller请求对象
空指针异常

解决：
	获取主线程ServletRequestAttributes，给每个异步线程复制一份
```

```java
/**
 * 获取结算页（confirm.html）VO数据
 */
@Override
public OrderConfirmVO OrderConfirmVO() throws ExecutionException, InterruptedException {
    OrderConfirmVO result = new OrderConfirmVO();
    // 获取当前用户
    MemberResponseVO member = LoginUserInterceptor.loginUser.get();

    // 获取当前线程上下文环境器
    ServletRequestAttributes requestAttributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();
    CompletableFuture<Void> addressFuture = CompletableFuture.runAsync(() -> {
        // 1.查询封装当前用户收货列表
        // 同步上下文环境器，解决异步无法从ThreadLocal获取RequestAttributes
        RequestContextHolder.setRequestAttributes(requestAttributes);
        List<MemberAddressVO> address = memberFeignService.getAddress(member.getId());
        result.setMemberAddressVos(address);
    }, executor);

    CompletableFuture<Void> cartFuture = CompletableFuture.runAsync(() -> {
        // 2.查询购物车所有选中的商品
        // 同步上下文环境器，解决异步无法从ThreadLocal获取RequestAttributes
        RequestContextHolder.setRequestAttributes(requestAttributes);
        // 请求头应该放入GULIMALLSESSION（feign请求会根据requestInterceptors构建请求头）
        List<OrderItemVO> items = cartFeignService.getCurrentCartItems();
        result.setItems(items);
    }, executor);

    // 3.查询用户积分
    Integer integration = member.getIntegration();// 积分
    result.setIntegration(integration);

    // 4.金额数据自动计算

    // 5.TODO 防重令牌

    // 阻塞等待所有异步任务返回
    CompletableFuture.allOf(addressFuture, cartFuture).get();

    return result;
}
```

### 计算运费

```java
/**
 * 获取运费
 * @param addrId 会员收货地址ID
 */
@Override
public FareVO getFare(Long addrId) {
    FareVO fareVo = new FareVO();
    //收获地址的详细信息
    R addrInfo = memberFeignService.info(addrId);
    MemberAddressVO memberAddressVo = addrInfo.getData("memberReceiveAddress", new TypeReference<MemberAddressVO>() {
    });
    if (memberAddressVo != null) {
        String phone = memberAddressVo.getPhone();
        //截取用户手机号码最后一位作为我们的运费计算
        //1558022051
        String fare = phone.substring(phone.length() - 1);
        BigDecimal bigDecimal = new BigDecimal(fare);
        fareVo.setFare(bigDecimal);
        fareVo.setAddress(memberAddressVo);
        return fareVo;
    }
    return null;
}
```

## 5.幂等性处理

```json
哪些情况需要防止：
	用户多次点击按钮
	用户页面回退再次提交
	微服务互相调用，由于网络问题，导致请求失败。feign触发重试机制
	其他业务情况
	例如update tab1 set col1=col1+1 where col2 = 2，每次执行结果不一样

天然幂等性：
	1.查询接口
	2.更新接口update tab1 set col1=1 where col2=2
	3.delete from user where userId = 1
	4.insert user(userId, name) values(1, 'wan')，其中userId为主键
```

### 5.1.token机制

```json
	服务器存储了一个令牌，页面请求时要带上令牌，服务器接收请求后会匹配令牌，匹配成功则删除令牌（再次提交则匹配失败，服务器已删除令牌。但是F5刷新的话就不一样了，会有新的token产生）
	注意：
	1.删除令牌要在执行业务代码之前
	2.获取redis令牌、令牌匹配、令牌删除要保证原子性（lua脚本）
```

### 5.2.各种锁机制

```json
1.数据库悲观锁
	使用select* from xxx where id = 1 for update;查询的时候锁定该条数据
	注意：
		悲观锁使用时一般伴随事务一起使用，数据锁定时间可能会很长，需要根据实际情况选用。
		id字段一定是主键或者唯一索引，不然可能造成锁表的结果，处理起来会非常麻烦。

2.数据库乐观锁【带上版本号】
	这种方法适合在更新的场景中
update t_goods set count = count-1,version =version + 1 where good_id=2 and version = 1
	根据version版本，也就是在操作库存前先获取当前商品的version版本号，然后操作的时候带上此version号。
	第一次操作库存时，得到version为1，调用库存服务version变成了2﹔但返回给订单服务出现了问题，订单服务又一次发起调用库存服务，当订单服务传的version还是1，再执行上面的sal语句时，就不会执行﹔因为version已经变为2了，where条件就不成立。这样就保证了不管调用几次，只会真正的处理一次。
    乐观锁主要使用于处理读多写少的问题

3.分布式锁：
	例如集群下多个定时器处理相同的数据，可以加分布式锁，锁定此数据，处理完成后释放锁。获取到锁的必须先判断这个数据是否被处理过（double check）
```

### 5.3.各种唯一约束

```json
1.数据库唯一约束 order_sn字段【数据库层面】

2.redis set防重【百度网盘妙传功能】
需要处理的数据 计算MD5放入redis的set，每次处理数据，先看MD5是否存在，存在就不处理
```

### 5.4.防重表

```json
数据库创建防重表，插入成功才可以操作【不采用，DB慢】
	使用订单号orderNo作为去重表唯一索引，然后将数据插入去重表+业务操作 放在同一事物中，如果插入失败事物回滚导致业务操作也同时回滚，（如果业务操作失败也会导致插入去重表回滚）保证了数据一致性
```

### 5.5.全局唯一id

```json
调用接口时，生成一个唯一ID，redis将数据保存到集合中（去重），存在即处理过
	情景1：feign调用
		生成一个请求唯一ID，A调用B时带上唯一ID，B处理feign请求时判断此唯一ID是否已处理（feign重试时会带上相同ID）
	
	情景2：页面请求
	可以使用nginx设置每一个请求的唯一id，proxy_set_header X-Request-ld $request_id; 【链路追踪】
	但是没办法保证请求幂等性，因为每次请求nginx都会生成一个新的ID
```

## 6.结算页

**流程图：**

![1640702742647](/assert/1640702742647.png)

```json
结算页数据：
	获取当时购物车选中商品并计算价格
```

```java
@Service("orderService")
public class OrderServiceImpl extends ServiceImpl<OrderDao, OrderEntity> implements OrderService {

    @Autowired
    MemberFeignService memberFeignService;
    @Autowired
    CartFeignService cartFeignService;
    @Autowired
    WmsFeignService wmsFeignService;
    @Autowired
    ThreadPoolExecutor executor;
    @Autowired
    StringRedisTemplate redisTemplate;

    /**
     * 获取结算页（confirm.html）VO数据
     */
    @Override
    public OrderConfirmVO OrderConfirmVO() throws ExecutionException, InterruptedException {
        OrderConfirmVO result = new OrderConfirmVO();
        // 获取当前用户
        MemberResponseVO member = LoginUserInterceptor.loginUser.get();

        // 获取当前线程上下文环境器
        ServletRequestAttributes requestAttributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();
        CompletableFuture<Void> addressFuture = CompletableFuture.runAsync(() -> {
            // 1.查询封装当前用户收货列表
            // 同步上下文环境器，解决异步无法从ThreadLocal获取RequestAttributes
            RequestContextHolder.setRequestAttributes(requestAttributes);
            List<MemberAddressVO> address = memberFeignService.getAddress(member.getId());
            result.setMemberAddressVos(address);
        }, executor);

        CompletableFuture<Void> cartFuture = CompletableFuture.runAsync(() -> {
            // 2.查询购物车所有选中的商品
            // 同步上下文环境器，解决异步无法从ThreadLocal获取RequestAttributes
            RequestContextHolder.setRequestAttributes(requestAttributes);
            // 请求头应该放入GULIMALLSESSION（feign请求会根据requestInterceptors构建请求头）
            List<OrderItemVO> items = cartFeignService.getCurrentCartItems();
            result.setItems(items);
        }, executor).thenRunAsync(() -> {
            // 3.批量查询库存（有货/无货）
            List<Long> skuIds = result.getItems().stream().map(item -> item.getSkuId()).collect(Collectors.toList());
            R skuHasStock = wmsFeignService.getSkuHasStock(skuIds);
            List<SkuHasStockTO> skuHasStocks = skuHasStock.getData(new TypeReference<List<SkuHasStockTO>>() {
            });
            Map<Long, Boolean> stocks = skuHasStocks.stream().collect(Collectors.toMap(key -> key.getSkuId(), val -> val.getHasStock()));
            result.setStocks(stocks);
        });

        // 4.查询用户积分
        Integer integration = member.getIntegration();// 积分
        result.setIntegration(integration);

        // 5.金额数据自动计算

        // 6.防重令牌
        String token = tokenUtil.createToken();
        result.setUniqueToken(token);

        // 阻塞等待所有异步任务返回
        CompletableFuture.allOf(addressFuture, cartFuture).get();

        return result;
    }
}
```

## 7.提交订单+幂等性处理

![1640781900850](/assert/1640781900850.png)

![1640781972281](/assert/1640781972281.png)

### 队列业务规则截图

![QQ图片20220102210446](/assert/QQ图片20220102210446.png)
![1598801376492](/assert/1598801376492.png)

### 7.1.第一版（无事务）

#### 7.1.1.生成订单

```java
/**
 * @Author: wanzenghui
 * @Date: 2021/12/20 21:59
 */
@Controller
public class OrderWebController {

    @Autowired
    private OrderService orderService;

    /**
     * 创建订单
     * 创建成功，跳转订单支付页
     * 创建失败，跳转结算页
     * 无需提交要购买的商品，提交订单时会实时查询最新的购物车商品选中数据提交
     */
    @TokenVerify
    @PostMapping(value = "/submitOrder")
    public String submitOrder(OrderSubmitVO vo, Model model, RedirectAttributes attributes) {
        try {
            SubmitOrderResponseVO orderVO = orderService.submitOrder(vo);
            // 创建订单成功，跳转收银台
            model.addAttribute("submitOrderResp", orderVO);// 封装VO订单数据，供页面解析[订单号、应付金额]
            return "pay";
        } catch (Exception e) {
            // 下单失败回到订单结算页
            if (e instanceof VerifyPriceException) {
                String message = ((VerifyPriceException) e).getMessage();
                attributes.addFlashAttribute("msg", "下单失败" + message);
            } else if (e instanceof NoStockException) {
                String message = ((NoStockException) e).getMessage();
                attributes.addFlashAttribute("msg", "下单失败" + message);
            }
            return "redirect:http://order.gulimall.com/toTrade";
        }
    }
}
```

```java
@Service("orderService")
public class OrderServiceImpl extends ServiceImpl<OrderDao, OrderEntity> implements OrderService {

    // 提交订单共享提交数据
    private ThreadLocal<OrderSubmitVO> confirmVoThreadLocal = new ThreadLocal<>();

    @Autowired
    MemberFeignService memberFeignService;
    @Autowired
    CartFeignService cartFeignService;
    @Autowired
    WmsFeignService wmsFeignService;
    @Autowired
    ProductFeignService productFeignService;
    @Autowired
    OrderItemServiceImpl orderItemService;
    @Autowired
    ThreadPoolExecutor executor;
    @Autowired
    TokenUtil tokenUtil;

    /**
     * 创建订单
     * GlobalTransactional：seata分布式事务，不适合高并发场景（默认基于AT实现）
     * @param vo 收货地址、发票信息、使用的优惠券、备注、应付总额、令牌
     */
    //@GlobalTransactional
    @Transactional
    @Override
    public SubmitOrderResponseVO submitOrder(OrderSubmitVO orderSubmitVO) throws Exception {
        SubmitOrderResponseVO result = new SubmitOrderResponseVO();// 返回值
        // 创建订单线程共享提交数据
        confirmVoThreadLocal.set(orderSubmitVO);
        // 1.生成订单实体对象（订单 + 订单项）
        OrderCreateTO order = createOrder();
        // 2.验价应付金额（允许0.01误差，前后端计算不一致）
        if (Math.abs(orderSubmitVO.getPayPrice().subtract(order.getPayPrice()).doubleValue()) >= 0.01) {
            // 验价不通过
            throw new VerifyPriceException();
        }
        // 验价成功
        // 3.保存订单
        saveOrder(order);
        // 4.库存锁定（wms_ware_sku）
        // 封装待锁定商品项TO
        WareSkuLockTO lockTO = new WareSkuLockTO();
        lockTO.setOrderSn(order.getOrder().getOrderSn());
        List<OrderItemVO> locks = order.getOrderItems().stream().map((item) -> {
            OrderItemVO lock = new OrderItemVO();
            lock.setSkuId(item.getSkuId());
            lock.setCount(item.getSkuQuantity());
            lock.setTitle(item.getSkuName());
            return lock;
        }).collect(Collectors.toList());
        lockTO.setLocks(locks);// 待锁定订单项
        R response = wmsFeignService.orderLockStock(lockTO);
        if (response.getCode() == 0) {
            // 锁定成功
            // TODO 5.远程扣减积分
            // 封装响应数据返回
            System.out.println(10 / 0);
            result.setOrder(order.getOrder());
            return result;
        } else {
            // 锁定失败
            throw new NoStockException("");
        }
    }

    /**
     * 封装订单实体类对象
     * 订单 + 订单项
     */
    private OrderCreateTO createOrder() throws Exception {
        OrderCreateTO result = new OrderCreateTO();// 订单
        // 1.生成订单号
        String orderSn = IdWorker.getTimeId();
        // 2.生成订单实体对象
        OrderEntity orderEntity = buildOrder(orderSn);
        // 3.生成订单项实体对象
        List<OrderItemEntity> orderItemEntities = buildOrderItems(orderSn);
        // 4.汇总封装（封装订单价格[订单项价格之和]、封装订单积分、成长值[订单项积分、成长值之和]）
        summaryFillOrder(orderEntity, orderItemEntities);

        // 5.封装TO返回
        result.setOrder(orderEntity);
        result.setOrderItems(orderItemEntities);
        result.setFare(orderEntity.getFreightAmount());
        result.setPayPrice(orderEntity.getPayAmount());// 设置应付金额
        return result;
    }

    /**
     * 生成订单实体对象
     *
     * @param orderSn 订单号
     */
    private OrderEntity buildOrder(String orderSn) {
        OrderEntity orderEntity = new OrderEntity();// 订单实体类
        // 1.封装会员ID
        MemberResponseVO member = LoginUserInterceptor.loginUser.get();// 拦截器获取登录信息
        orderEntity.setMemberId(member.getId());
        // 2.封装订单号
        orderEntity.setOrderSn(orderSn);
        // 3.封装运费
        OrderSubmitVO orderSubmitVO = confirmVoThreadLocal.get();
        R fare = wmsFeignService.getFare(orderSubmitVO.getAddrId());// 获取地址
        FareVO fareVO = fare.getData(new TypeReference<FareVO>() {
        });
        orderEntity.setFreightAmount(fareVO.getFare());
        // 4.封装收货地址信息
        orderEntity.setReceiverName(fareVO.getAddress().getName());// 收货人名字
        orderEntity.setReceiverPhone(fareVO.getAddress().getPhone());// 收货人电话
        orderEntity.setReceiverProvince(fareVO.getAddress().getProvince());// 省
        orderEntity.setReceiverCity(fareVO.getAddress().getCity());// 市
        orderEntity.setReceiverRegion(fareVO.getAddress().getRegion());// 区
        orderEntity.setReceiverDetailAddress(fareVO.getAddress().getDetailAddress());// 详细地址
        orderEntity.setReceiverPostCode(fareVO.getAddress().getPostCode());// 收货人邮编
        // 5.封装订单状态信息
        orderEntity.setStatus(OrderConstant.OrderStatusEnum.CREATE_NEW.getCode());
        // 6.设置自动确认时间
        orderEntity.setAutoConfirmDay(OrderConstant.autoConfirmDay);// 7天
        // 7.设置未删除状态
        orderEntity.setDeleteStatus(ObjectConstant.BooleanIntEnum.NO.getCode());
        // 8.设置时间
        Date now = new Date();
        orderEntity.setCreateTime(now);
        orderEntity.setModifyTime(now);
        return orderEntity;
    }

    /**
     * 生成订单项实体对象
     * 购物车每项选中商品产生一个订单项
     */
    private List<OrderItemEntity> buildOrderItems(String orderSn) throws Exception {
        // 封装订单项（最后确定的价格，不会再改变）
        List<OrderItemVO> currentCartItems = cartFeignService.getCurrentCartItems();// 获取当前用户购物车所有商品
        if (!CollectionUtils.isEmpty(currentCartItems)) {
            // 遍历购物车商品，循环构建每个订单项
            List<OrderItemEntity> itemEntities = currentCartItems.stream()
                    .filter(cartItem -> cartItem.getCheck())
                    .map(cartItem -> buildOrderItem(orderSn, cartItem))
                    .collect(Collectors.toList());
            return itemEntities;
        } else {
            throw new Exception();
        }
    }

    /**
     * 生成单个订单项实体对象
     */
    private OrderItemEntity buildOrderItem(String orderSn, OrderItemVO cartItem) {
        OrderItemEntity itemEntity = new OrderItemEntity();
        // 1.封装订单号
        itemEntity.setOrderSn(orderSn);
        // 2.封装SPU信息
        R spuInfo = productFeignService.getSpuInfoBySkuId(cartItem.getSkuId());// 查询SPU信息
        SpuInfoTO spuInfoTO = spuInfo.getData(new TypeReference<SpuInfoTO>() {
        });
        itemEntity.setSpuId(spuInfoTO.getId());
        itemEntity.setSpuName(spuInfoTO.getSpuName());
        itemEntity.setSpuBrand(spuInfoTO.getSpuName());
        itemEntity.setCategoryId(spuInfoTO.getCatalogId());
        // 3.封装SKU信息
        itemEntity.setSkuId(cartItem.getSkuId());
        itemEntity.setSkuName(cartItem.getTitle());
        itemEntity.setSkuPic(cartItem.getImage());// 商品sku图片
        itemEntity.setSkuPrice(cartItem.getPrice());// 这个是最新价格，购物车模块查询数据库得到
        itemEntity.setSkuQuantity(cartItem.getCount());// 当前商品数量
        String skuAttrsVals = String.join(";", cartItem.getSkuAttrValues());
        itemEntity.setSkuAttrsVals(skuAttrsVals);// 商品销售属性组合["颜色:星河银","版本:8GB+256GB"]
        // 4.优惠信息【不做】

        // 5.积分信息
        int num = cartItem.getPrice().multiply(new BigDecimal(cartItem.getCount())).intValue();// 分值=单价*数量
        itemEntity.setGiftGrowth(num);// 成长值
        itemEntity.setGiftIntegration(num);// 积分

        // 6.价格信息
        itemEntity.setPromotionAmount(BigDecimal.ZERO);// 促销金额
        itemEntity.setCouponAmount(BigDecimal.ZERO);// 优惠券金额
        itemEntity.setIntegrationAmount(BigDecimal.ZERO);// 积分优惠金额
        BigDecimal realAmount = itemEntity.getSkuPrice().multiply(new BigDecimal(itemEntity.getSkuQuantity()))
                .subtract(itemEntity.getPromotionAmount())
                .subtract(itemEntity.getCouponAmount())
                .subtract(itemEntity.getIntegrationAmount());
        itemEntity.setRealAmount(realAmount);// 实际金额，减去所有优惠金额
        return itemEntity;
    }

    /**
     * 汇总封装订单
     * 1.计算订单总金额
     * 2.汇总积分、成长值
     * 3.汇总应付总额 = 订单总金额 + 运费
     *
     * @param orderEntity       订单
     * @param orderItemEntities 订单项
     */
    private void summaryFillOrder(OrderEntity orderEntity, List<OrderItemEntity> orderItemEntities) {
        // 1.订单总额、促销总金额、优惠券总金额、积分优惠总金额
        BigDecimal total = new BigDecimal(0);
        BigDecimal coupon = new BigDecimal(0);
        BigDecimal promotion = new BigDecimal(0);
        BigDecimal integration = new BigDecimal(0);
        // 2.积分、成长值
        Integer giftIntegration = 0;
        Integer giftGrowth = 0;
        for (OrderItemEntity itemEntity : orderItemEntities) {
            total = total.add(itemEntity.getRealAmount());// 订单总额
            coupon = coupon.add(itemEntity.getCouponAmount());// 促销总金额
            promotion = promotion.add(itemEntity.getPromotionAmount());// 优惠券总金额
            integration = integration.add(itemEntity.getIntegrationAmount());// 积分优惠总金额
            giftIntegration = giftIntegration + itemEntity.getGiftIntegration();// 积分
            giftGrowth = giftGrowth + itemEntity.getGiftGrowth();// 成长值
        }
        orderEntity.setTotalAmount(total);
        orderEntity.setCouponAmount(coupon);
        orderEntity.setPromotionAmount(promotion);
        orderEntity.setIntegrationAmount(integration);
        orderEntity.setIntegration(giftIntegration);// 积分
        orderEntity.setGrowth(giftGrowth);// 成长值

        // 3.应付总额
        orderEntity.setPayAmount(orderEntity.getTotalAmount().add(orderEntity.getFreightAmount()));// 订单总额 +　运费
    }

    /**
     * 保存订单
     * 将封装生成的订单对象 + 订单项对象持久化到DB
     * @param order
     */
    private void saveOrder(OrderCreateTO order) {
        // 1.持久化订单对象
        OrderEntity orderEntity = order.getOrder();
        save(orderEntity);

        // 2.持久化订单项对象
        List<OrderItemEntity> itemEntities = order.getOrderItems();
        orderItemService.saveBatch(itemEntities);
    }
}
```

#### 7.1.2锁定库存

![1640824042767](/assert/1640824042767.png)

```json
描述：
	所有商品锁定成功即成功，任一商品锁定失败创建订单回滚
```

```java
这里没有给出代码，可以查看【第二版】
```
### 7.2.第二版（柔性事务）
![1640911185927](/assert/1640911185927.png)
#### 7.2.1.实现方案
```json
创建订单是高并发场景，不采用Seata（默认Seata是采用AT模式【2PC模式的变种】，性能低）
采用方案：【柔性事务】
	保证AP，采用本地事务+延时队列+监听死信队列解锁库存 的方案实现最终一致性
```
```json
订单模块一个延时队列+死信队列，用于30min关闭订单
库存模块一个延时队列+死信队列，用于40min解锁库存
```

![QQ图片20220102211108](/assert/QQ图片20220102211108.png)

![QQ图片20220102215544.jpg](/assert/QQ图片20220102215544.jpg)

**<u>优化：</u>**

![QQ图片20220102220024.jpg](/assert/QQ图片20220102220024.jpg)

```json
可靠消息+最终一致性：
	锁库存时，往队列发送一条库存解锁消息（在队列中设置超时时间而不是在消息中设置，具体查看MQ.md）
	消息超时后经过死信路由到达延时队列，解锁库存service监听延时队列，查询订单状态判断是否需要解锁库存
```

#### 7.2.2.实现步骤

```
延时队列、死信队列
```

##### order模块队列

```json
1.order创建关闭订单的延时队列、死信队列、交换机、绑定关系
/**
 * 创建队列，交换机，延时队列，绑定关系 的configuration
 * Broker中的Queue、Exchange、Binding不存在的情况下，会自动创建（在RabbitMQ），不会重复创建覆盖
 */
@Configuration
public class MyRabbitMQConfig {

    /**
     * 延时队列
     */
    @Bean
    public Queue orderDelayQueue() {
        /**
         * Queue(String name,  队列名字
         *       boolean durable,  是否持久化
         *       boolean exclusive,  是否排他
         *       boolean autoDelete, 是否自动删除
         *       Map<String, Object> arguments) 属性【TTL、死信路由、死信路由键】
         */
        HashMap<String, Object> arguments = new HashMap<>();
        arguments.put("x-dead-letter-exchange", "order-event-exchange");// 死信路由
        arguments.put("x-dead-letter-routing-key", "order.release.order");// 死信路由键
        arguments.put("x-message-ttl", 60000); // 消息过期时间 1分钟
        Queue queue = new Queue("order.delay.queue", true, false, false, arguments);

        return queue;
    }

    /**
     * 交换机（死信路由）
     */
    @Bean
    public Exchange orderEventExchange() {
        return new TopicExchange("order-event-exchange", true, false);
    }

    /**
     * 死信队列
     */
    @Bean
    public Queue orderReleaseQueue() {
        Queue queue = new Queue("order.release.order.queue", true, false, false);
        return queue;
    }

    /**
     * 绑定：交换机与延迟队列
     */
    @Bean
    public Binding orderCreateBinding() {
        /**
         * String destination, 目的地（队列名或者交换机名字）
         * DestinationType destinationType, 目的地类型（Queue、Exhcange）
         * String exchange,
         * String routingKey,
         * Map<String, Object> arguments
         **/
        return new Binding("order.delay.queue",
                Binding.DestinationType.QUEUE,
                "order-event-exchange",
                "order.create.order",
                null);
    }

    /**
     * 绑定：交换机与死信队列
     */
    @Bean
    public Binding orderReleaseBinding() {
        return new Binding("order.release.order.queue",
                Binding.DestinationType.QUEUE,
                "order-event-exchange",
                "order.release.order",
                null);
    }

    /**
     * 绑定：订单释放直接和库存释放进行
     */
    @Bean
    public Binding orderReleaseOtherBinding() {
        return new Binding("stock.release.stock.queue",
                Binding.DestinationType.QUEUE,
                "order-event-exchange",
                "order.release.other.#",
                null);
    }
}
```
##### ware模块队列

```java
1.ware模块导入mq依赖
<!--amqp高级消息队列协议，rabbitmq实现-->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-amqp</artifactId>
</dependency>

2.ware模块导入配置
spring:
  rabbitmq:
    host: 192.168.56.10
    port: 5672
    # 虚拟主机
    virtual-host: /
    # 开启发送端发送确认，无论是否到达broker都会触发回调【发送端确认机制+本地事务表】
    publisher-confirm-type: correlated
    # 开启发送端抵达队列确认，消息未被队列接收时触发回调【发送端确认机制+本地事务表】
    publisher-returns: true
    # 消息在没有被队列接收时是否强行退回
    template:
      mandatory: true
    # 消费者手动确认模式，关闭自动确认，否则会消息丢失
    listener:
      simple:
        acknowledge-mode: manual

3.添加注解
// 开启rabbit
@EnableRabbit

4.创建配置类
/**
 * @Author: wanzenghui
 * @Date: 2021/12/15 0:04
 */
@Configuration
public class MyRabbitConfig {

    @Autowired
    RabbitTemplate rabbitTemplate;

    @Bean
    public MessageConverter messageConverter() {
        // 使用json序列化器来序列化消息，发送消息时，消息对象会被序列化成json格式
        return new Jackson2JsonMessageConverter();
    }

    /**
     * 定制RabbitTemplate
     * 1、服务收到消息就会回调
     * 1、spring.rabbitmq.publisher-confirms: true
     * 2、设置确认回调
     * 2、消息正确抵达队列就会进行回调
     * 1、spring.rabbitmq.publisher-returns: true
     * spring.rabbitmq.template.mandatory: true
     * 2、设置确认回调ReturnCallback
     * <p>
     * 3、消费端确认(保证每个消息都被正确消费，此时才可以broker删除这个消息)
     */
    @PostConstruct   // (MyRabbitConfig对象创建完成以后，执行这个方法)
    public void initRabbitTemplate() {
        /**
         * 发送消息触发confirmCallback回调
         * @param correlationData：当前消息的唯一关联数据（如果发送消息时未指定此值，则回调时返回null）
         * @param ack：消息是否成功收到（ack=true，消息抵达Broker）
         * @param cause：失败的原因
         */
        rabbitTemplate.setConfirmCallback((correlationData, ack, cause) -> {
            System.out.println("发送消息触发confirmCallback回调" +
                    "\ncorrelationData ===> " + correlationData +
                    "\nack ===> " + ack + "" +
                    "\ncause ===> " + cause);
            System.out.println("=================================================");
        });

        /**
         * 消息未到达队列触发returnCallback回调
         * 只要消息没有投递给指定的队列，就触发这个失败回调
         * @param message：投递失败的消息详细信息
         * @param replyCode：回复的状态码
         * @param replyText：回复的文本内容
         * @param exchange：接收消息的交换机
         * @param routingKey：接收消息的路由键
         */
        rabbitTemplate.setReturnCallback((message, replyCode, replyText, exchange, routingKey) -> {
            // 需要修改数据库 消息的状态【后期定期重发消息】
            System.out.println("消息未到达队列触发returnCallback回调" +
                    "\nmessage ===> " + message +
                    "\nreplyCode ===> " + replyCode +
                    "\nreplyText ===> " + replyText +
                    "\nexchange ===> " + exchange +
                    "\nroutingKey ===> " + routingKey);
            System.out.println("==================================================");
        });
    }
}

5.创建ware解锁库存的延时队列、死信队列、交换机、绑定关系
/**
 * 创建队列，交换机，延时队列，绑定关系 的configuration
 * 1.Broker中的Queue、Exchange、Binding不存在的情况下，会自动创建（在RabbitMQ），不会重复创建覆盖
 * 2.懒加载，只有第一次使用的时候才会创建（例如监听队列）
 */
@Configuration
public class MyRabbitMQConfig {
    /**
     * 用于首次创建队列、交换机、绑定关系的监听
     * @param message
     */
    @RabbitListener(queues = "stock.release.stock.queue")
    public void handle(Message message) {
    }
    
    /**
     * 交换机
     * Topic，可以绑定多个队列
     */
    @Bean
    public Exchange stockEventExchange() {
        //String name, boolean durable, boolean autoDelete, Map<String, Object> arguments
        return new TopicExchange("stock-event-exchange", true, false);
    }

    /**
     * 死信队列
     */
    @Bean
    public Queue stockReleaseStockQueue() {
        //String name, boolean durable, boolean exclusive, boolean autoDelete, Map<String, Object> arguments
        return new Queue("stock.release.stock.queue", true, false, false);
    }

    /**
     * 延时队列
     */
    @Bean
    public Queue stockDelay() {
        HashMap<String, Object> arguments = new HashMap<>();
        arguments.put("x-dead-letter-exchange", "stock-event-exchange");
        arguments.put("x-dead-letter-routing-key", "stock.release");
        // 消息过期时间 2分钟
        arguments.put("x-message-ttl", 120000);
        return new Queue("stock.delay.queue", true, false, false,arguments);
    }

    /**
     * 绑定：交换机与死信队列
     */
    @Bean
    public Binding stockLocked() {
        //String destination, DestinationType destinationType, String exchange, String routingKey,
        // 			Map<String, Object> arguments
        return new Binding("stock.release.stock.queue",
                Binding.DestinationType.QUEUE,
                "stock-event-exchange",
                "stock.release.#",
                null);
    }

    /**
     * 绑定：交换机与延时队列
     */
    @Bean
    public Binding stockLockedBinding() {
        return new Binding("stock.delay.queue",
                Binding.DestinationType.QUEUE,
                "stock-event-exchange",
                "stock.locked",
                null);
    }
}
```

#### 7.2.3.解锁场景

```json
场景：
	1.下订单成功，用户手动取消 || 订单过期未支付
	2.其他业务调用失败，订单回滚，但库存锁定成功（最终一致性，需要解锁库存）
```

#### 7.2.4.锁定库存

```json
1.锁定库存
2.往库存工作单存储当前锁定（本地事务表）
3.往延时队列发送库存锁定成功消息
```
```java
/**
 * 库存锁定，sql执行锁定锁定
 *
 * @param lockTO
 * @return 锁定结果
 * @Transactional(rollbackFor = NoStockException.class)：指定的异常出现会导致回滚
 * 未指定异常，任何运行时异常都会导致回滚，可以省略rollbackFor
 */
@Transactional
@Override
public Boolean orderLockStock(WareSkuLockTO lockTO) {
    // 按照收货地址找到就近仓库，锁定库存（暂未实现）
    // 采用方案：获取每项商品在哪些仓库有库存，轮询尝试锁定，任一商品锁定失败回滚

    // 1.往库存工作单存储当前锁定（本地事务表）
    WareOrderTaskEntity taskEntity = new WareOrderTaskEntity();
    taskEntity.setOrderSn(lockTO.getOrderSn());
    orderTaskService.save(taskEntity);

    // 2.封装待锁定库存项Map
    Map<Long, OrderItemVO> lockItemMap = lockTO.getLocks().stream().collect(Collectors.toMap(key -> key.getSkuId(), val -> val));
    // 3.查询（库存 - 库存锁定 >= 待锁定库存数）的仓库
    List<WareSkuEntity> wareEntities = baseMapper.selectListHasSkuStock(lockItemMap.keySet()).stream().filter(entity -> entity.getStock() - entity.getStockLocked() >= lockItemMap.get(entity.getSkuId()).getCount()).collect(Collectors.toList());
    // 判断是否查询到仓库
    if (CollectionUtils.isEmpty(wareEntities)) {
        // 匹配失败，所有商品项没有库存
        Set<Long> skuIds = lockItemMap.keySet();
        throw new NoStockException(skuIds);
    }
    // 将查询出的仓库数据封装成Map，key:skuId  val:wareId
    Map<Long, List<WareSkuEntity>> wareMap = wareEntities.stream().collect(Collectors.groupingBy(key -> key.getSkuId()));
    // 4.判断是否为每一个商品项至少匹配了一个仓库
    List<WareOrderTaskDetailEntity> taskDetails = new ArrayList<>();// 库存锁定工作单详情
    Map<Long, StockLockedTO> lockedMessageMap = new HashMap<>();// 库存锁定工作单消息
    if (wareMap.size() < lockTO.getLocks().size()) {
        // 匹配失败，部分商品没有库存
        Set<Long> skuIds = lockItemMap.keySet();
        skuIds.removeAll(wareMap.keySet());// 求商品项差集
        throw new NoStockException(skuIds);
    } else {
        // 所有商品都存在有库存的仓库
        // 5.锁定库存
        for (Map.Entry<Long, List<WareSkuEntity>> entry : wareMap.entrySet()) {
            Boolean skuStocked = false;
            Long skuId = entry.getKey();// 商品
            OrderItemVO item = lockItemMap.get(skuId);
            Integer count = item.getCount();// 待锁定个数
            List<WareSkuEntity> hasStockWares = entry.getValue();// 有足够库存的仓库
            for (WareSkuEntity ware : hasStockWares) {
                Long num = baseMapper.lockSkuStock(skuId, ware.getWareId(), count);
                if (num == 1) {
                    // 锁定成功，跳出循环
                    skuStocked = true;
                    // 创建库存锁定工作单详情（每一件商品锁定详情）
                    WareOrderTaskDetailEntity taskDetail = new WareOrderTaskDetailEntity(null, skuId,
                            item.getTitle(), count, taskEntity.getId(), ware.getWareId(),
                            WareOrderTaskConstant.LockStatusEnum.LOCKED.getCode());
                    taskDetails.add(taskDetail);
                    // 创建库存锁定工作单消息（每一件商品一条消息）
                    StockDetailTO detailMessage = new StockDetailTO();
                    BeanUtils.copyProperties(taskDetail, detailMessage);
                    StockLockedTO lockedMessage = new StockLockedTO(taskEntity.getId(), detailMessage);
                    lockedMessageMap.put(skuId, lockedMessage);
                    break;
                }
            }
            if (!skuStocked) {
                // 匹配失败，当前商品所有仓库都未锁定成功
                throw new NoStockException(skuId);
            }
        }
    }

    // 6.往库存工作单详情存储当前锁定（本地事务表）
    orderTaskDetailService.saveBatch(taskDetails);

    // 7.发送消息
    for (WareOrderTaskDetailEntity taskDetail : taskDetails) {
        StockLockedTO message = lockedMessageMap.get(taskDetail.getSkuId());
        message.getDetail().setId(taskDetail.getId());// 存储库存详情ID
        rabbitTemplate.convertAndSend("stock-event-exchange", "stock.locked", message);
    }
    return true;
}
```
#### 7.2.5.生成订单

```json
下单成功，往订单解锁延时队列发送消息
// 发送创建订单到延时队列
```

```java
/**
 * 创建订单
 * GlobalTransactional：seata分布式事务，不适合高并发场景（默认基于AT实现）
 *
 * @param vo 收货地址、发票信息、使用的优惠券、备注、应付总额、令牌
 */
//@GlobalTransactional
@Transactional
@Override
public SubmitOrderResponseVO submitOrder(OrderSubmitVO orderSubmitVO) throws Exception {
    SubmitOrderResponseVO result = new SubmitOrderResponseVO();// 返回值
    // 创建订单线程共享提交数据
    confirmVoThreadLocal.set(orderSubmitVO);
    // 1.生成订单实体对象（订单 + 订单项）
    OrderCreateTO order = createOrder();
    // 2.验价应付金额（允许0.01误差，前后端计算不一致）
    if (Math.abs(orderSubmitVO.getPayPrice().subtract(order.getPayPrice()).doubleValue()) >= 0.01) {
        // 验价不通过
        throw new VerifyPriceException();
    }
    // 验价成功
    // 3.保存订单
    saveOrder(order);
    // 4.库存锁定（wms_ware_sku）
    // 封装待锁定商品项TO
    WareSkuLockTO lockTO = new WareSkuLockTO();
    lockTO.setOrderSn(order.getOrder().getOrderSn());
    List<OrderItemVO> locks = order.getOrderItems().stream().map((item) -> {
        OrderItemVO lock = new OrderItemVO();
        lock.setSkuId(item.getSkuId());
        lock.setCount(item.getSkuQuantity());
        lock.setTitle(item.getSkuName());
        return lock;
    }).collect(Collectors.toList());
    lockTO.setLocks(locks);// 待锁定订单项
    R response = wmsFeignService.orderLockStock(lockTO);
    if (response.getCode() == 0) {
        // 锁定成功
        // TODO 5.远程扣减积分
        // 封装响应数据返回
        result.setOrder(order.getOrder());
        //System.out.println(10 / 0); // 模拟订单回滚，库存不会滚
        // 6.发送创建订单到延时队列
        rabbitTemplate.convertAndSend("order-event-exchange", "order.create.order", order.getOrder());
        return result;
    } else {
        // 锁定失败
        throw new NoStockException("");
    }
}
```

##### bug_解锁订单晚于解锁库存执行

![QQ图片20220103181414](/assert/QQ图片20220103181414.png)

```
bug：
	订单解锁晚于库存解锁执行导致库存永远不会被解锁
	
bug重现：
	机器卡顿，订单解锁的消息延迟抵达，造成订单解锁晚于库存解锁执行，此时库存解锁失败，因为订单还处于未支付状态，导致库存未解锁，并且消息已经确认
	
解决方案：
	方案一：
		库存解锁消息重新入队（不建议，因为无法判断消息延迟的具体时间，造成消息空转浪费资源）
	方案二：
		消费订单解锁消息时，往库存解锁的死信队列丢一条消息（同时是消费者和生产者）
```

![QQ图片20220103182026](/assert/QQ图片20220103182026.png)

#### 7.2.6.解锁订单

```json
场景：
	1.订单过期未支付

实现：
	生成订单时创建消息放入延时队列
	解锁订单方法监听死信队列
	解锁订单时为了防止订单解锁晚于库存解锁的BUG，此时主动往解锁库存的死信队列发送一条消息
```

```java
/**
 * 创建队列，交换机，延时队列，绑定关系 的configuration
 * 1.Broker中的Queue、Exchange、Binding不存在的情况下，会自动创建（在RabbitMQ），不会重复创建覆盖
 * 2.懒加载，只有第一次使用的时候才会创建（例如监听队列）
 */
@Configuration
public class MyRabbitMQConfig {

    /**
     * 延时队列
     */
    @Bean
    public Queue orderDelayQueue() {
        /**
         * Queue(String name,  队列名字
         *       boolean durable,  是否持久化
         *       boolean exclusive,  是否排他
         *       boolean autoDelete, 是否自动删除
         *       Map<String, Object> arguments) 属性【TTL、死信路由、死信路由键】
         */
        HashMap<String, Object> arguments = new HashMap<>();
        arguments.put("x-dead-letter-exchange", "order-event-exchange");// 死信路由
        arguments.put("x-dead-letter-routing-key", "order.release.order");// 死信路由键
        arguments.put("x-message-ttl", 60000); // 消息过期时间 1分钟
        return new Queue("order.delay.queue", true, false, false, arguments);
    }

    /**
     * 交换机（死信路由）
     */
    @Bean
    public Exchange orderEventExchange() {
        return new TopicExchange("order-event-exchange", true, false);
    }

    /**
     * 死信队列
     */
    @Bean
    public Queue orderReleaseQueue() {
        return new Queue("order.release.order.queue", true, false, false);
    }

    /**
     * 绑定：交换机与订单解锁延迟队列
     */
    @Bean
    public Binding orderCreateBinding() {
        /**
         * String destination, 目的地（队列名或者交换机名字）
         * DestinationType destinationType, 目的地类型（Queue、Exhcange）
         * String exchange,
         * String routingKey,
         * Map<String, Object> arguments
         **/
        return new Binding("order.delay.queue",
                Binding.DestinationType.QUEUE,
                "order-event-exchange",
                "order.create.order",
                null);
    }

    /**
     * 绑定：交换机与订单解锁死信队列
     */
    @Bean
    public Binding orderReleaseBinding() {
        return new Binding("order.release.order.queue",
                Binding.DestinationType.QUEUE,
                "order-event-exchange",
                "order.release.order",
                null);
    }

    /**
     * 绑定：交换机与库存解锁
     */
    @Bean
    public Binding orderReleaseOtherBinding() {
        return new Binding("stock.release.stock.queue",
                Binding.DestinationType.QUEUE,
                "order-event-exchange",
                "order.release.other.#",
                null);
    }
}
```

```java
/**
 * 定时关单，监听死信队列
 * @Author: wanzenghui
 * @Date: 2022/1/3 17:24
 */
@Slf4j
@RabbitListener(queues = "order.release.order.queue")
@Component
public class OrderCloseListener {

    @Autowired
    OrderService orderService;

    @RabbitHandler
    public void handleOrderRelease(OrderEntity order, Message message, Channel channel) throws IOException {
        log.debug("订单解锁，订单号：" + order.getOrderSn());
        try {
            orderService.closeOrder(order);
            // 手动删除消息
            channel.basicAck(message.getMessageProperties().getDeliveryTag(), false);
        } catch (Exception e) {
            // 解锁失败 将消息重新放回队列，让别人消费
            channel.basicReject(message.getMessageProperties().getDeliveryTag(), true);
        }
    }
}



@Service("orderService")
public class OrderServiceImpl extends ServiceImpl<OrderDao, OrderEntity> implements OrderService {

    /**
     * 关闭订单
     */
    @Override
    public void closeOrder(OrderEntity order) {
        OrderEntity _order = getById(order.getId());
        if (OrderConstant.OrderStatusEnum.CREATE_NEW.getCode().equals(_order.getStatus())) {
            // 待付款状态允许关单
            OrderEntity temp = new OrderEntity();
            temp.setId(order.getId());
            temp.setStatus(OrderConstant.OrderStatusEnum.CANCLED.getCode());
            updateById(temp);

            // 发送消息给MQ
            OrderTO orderTO = new OrderTO();
            BeanUtils.copyProperties(_order, orderTO);
            //TODO 确保每个消息发送成功，给每个消息做好日志记录，(给数据库保存每一个详细信息)保存每个消息的详细信息
            //TODO 定期扫描数据库，重新发送失败的消息
            rabbitTemplate.convertAndSend("order-event-exchange", "order.release.other", orderTO);
        }
    }
}
```

```java
/**
 * 解锁库存，监听死信队列
 *
 * @author: wanzenghui
 **/
@Slf4j
@RabbitListener(queues = "stock.release.stock.queue")
@Component
public class StockReleaseListener {

    @Autowired
    private WareSkuService wareSkuService;

    /**
     * 客户取消订单，监听到消息
     */
    @RabbitHandler
    public void handleOrderCloseRelease(OrderTO orderTo, Message message, Channel channel) throws IOException {
        log.debug("订单关闭准备解锁库存，订单号：" + orderTo.getOrderSn());
        try {
            wareSkuService.unLockStock(orderTo);
            // 手动删除消息
            channel.basicAck(message.getMessageProperties().getDeliveryTag(), false);
        } catch (Exception e) {
            // 解锁失败 将消息重新放回队列，让别人消费
            channel.basicReject(message.getMessageProperties().getDeliveryTag(), true);
        }
    }
}


@Slf4j
@Service("wareSkuService")
public class WareSkuServiceImpl extends ServiceImpl<WareSkuDao, WareSkuEntity> implements WareSkuService {

    /**
     * 库存解锁
     * 订单解锁触发，防止库存解锁消息优先于订单解锁消息到期，导致库存无法解锁
     */
    @Transactional
    @Override
    public void unLockStock(OrderTO order) {
        String orderSn = order.getOrderSn();// 订单号
        // 1.根据订单号查询库存锁定工作单
        WareOrderTaskEntity task = orderTaskService.getOrderTaskByOrderSn(orderSn);
        // 2.按照工作单查询未解锁的库存，进行解锁
        List<WareOrderTaskDetailEntity> taskDetails = orderTaskDetailService.list(new QueryWrapper<WareOrderTaskDetailEntity>()
                .eq("task_id", task.getId())
                .eq("lock_status", WareOrderTaskConstant.LockStatusEnum.LOCKED.getCode()));// 并发问题
        // 3.解锁库存
        for (WareOrderTaskDetailEntity taskDetail : taskDetails) {
            unLockStock(taskDetail.getSkuId(), taskDetail.getWareId(), taskDetail.getSkuNum(), taskDetail.getId());
        }
    }

    /**
     * 库存解锁
     * 1.sql执行释放锁定
     * 2.更新库存工作单状态为已解锁
     *
     * @param skuId
     * @param wareId
     * @param count
     */
    public void unLockStock(Long skuId, Long wareId, Integer count, Long taskDetailId) {
        // 1.库存解锁
        baseMapper.unLockStock(skuId, wareId, count);

        // 2.更新工作单的状态 已解锁
        WareOrderTaskDetailEntity taskDetail = new WareOrderTaskDetailEntity();
        taskDetail.setId(taskDetailId);
        taskDetail.setLockStatus(WareOrderTaskConstant.LockStatusEnum.UNLOCKED.getCode());
        orderTaskDetailService.updateById(taskDetail);
    }
}
```

#### 7.2.7.解锁库存

```json
场景：
	1.下订单成功，用户手动取消 || 订单过期未支付
	2.订单回滚，其他业务调用失败，但库存锁定成功（最终一致性，解锁库存）

实现：
	监听死信队列，拿到库存锁定工作单解锁库存（解锁时判断是否允许解锁）
```

```java
/**
 * 监听死信队列，解锁库存
 * 库存解锁，监听
 *
 * @author: wanzenghui
 **/
@Slf4j
@RabbitListener(queues = "stock.release.stock.queue")
@Component
public class StockReleaseListener {

    @Autowired
    private WareSkuService wareSkuService;

    /**
     * 库存解锁（监听死信队列）
     * 场景：
     * 1.下订单成功【需要解锁】(订单过期未支付、被用户手动取消、其他业务调用失败（订单回滚）)
     * 2.下订单失败【无需解锁】(库存锁定失败（库存锁定已回滚，但消息已发出）)
     * <p>
     * 注意：需要开启手动确认，不要删除消息，当前解锁失败需要重复解锁
     */
    @RabbitHandler
    public void handleStockLockedRelease(StockLockedTO locked, Message message, Channel channel) throws IOException {
        log.debug("收到解锁库存消息");
        //当前消息是否重新派发过来
        // Boolean redelivered = message.getMessageProperties().getRedelivered();
        try {
            // 解锁库存
            wareSkuService.unLockStock(locked);
            // 解锁成功，手动确认
            channel.basicAck(message.getMessageProperties().getDeliveryTag(), false);
        } catch (Exception e) {
            // 解锁失败，消息入队
            channel.basicReject(message.getMessageProperties().getDeliveryTag(), true);
        }
    }
}



@Slf4j
@Service("wareSkuService")
public class WareSkuServiceImpl extends ServiceImpl<WareSkuDao, WareSkuEntity> implements WareSkuService {

    @Autowired
    WareOrderTaskServiceImpl orderTaskService;
    @Autowired
    WareOrderTaskDetailServiceImpl orderTaskDetailService;
    @Autowired
    OrderFeignService orderFeignService;

    /**
     * 库存解锁
     */
    @Override
    public void unLockStock(StockLockedTO locked) throws Exception {
        StockDetailTO taskDetailTO = locked.getDetail();// 库存工作单详情TO
        WareOrderTaskDetailEntity taskDetail = orderTaskDetailService.getById(taskDetailTO.getId());// 库存工作单详情Entity
        if (taskDetail != null) {
            // 1.工作单未回滚，需要解锁
            WareOrderTaskEntity task = orderTaskService.getById(locked.getId());// 库存工作单Entity
            R r = orderFeignService.getOrderByOrderSn(task.getOrderSn());// 订单Entity
            if (r.getCode() == 0) {
                // 订单数据返回成功
                OrderTO order = r.getData(new TypeReference<OrderTO>() {
                });
                if (order == null || OrderConstant.OrderStatusEnum.CANCLED.getCode().equals(order.getStatus())) {
                    // 2.订单已回滚 || 订单未回滚已取消状态
                    if (WareOrderTaskConstant.LockStatusEnum.LOCKED.getCode().equals(taskDetail.getLockStatus())) {
                        // 订单已锁定状态，需要解锁（消息确认）
                        unLockStock(taskDetailTO.getSkuId(), taskDetailTO.getWareId(), taskDetailTO.getSkuNum(), taskDetailTO.getId());
                    } else {
                        // 订单其他状态，不可解锁（消息确认）
                    }
                }
            } else {
                // 订单远程调用失败（消息重新入队）
                throw new Exception();
            }
        } else {
            // 3.无库存锁定工作单记录，已回滚，无需解锁（消息确认）
        }
    }

    /**
     * 库存解锁
     * 1.sql执行释放锁定
     * 2.更新库存工作单状态为已解锁
     *
     * @param skuId
     * @param wareId
     * @param count
     */
    @Override
    public void unLockStock(Long skuId, Long wareId, Integer count, Long taskDetailId) {
        // 1.库存解锁
        baseMapper.unLockStock(skuId, wareId, count);

        // 2.更新工作单的状态 已解锁
        WareOrderTaskDetailEntity taskDetail = new WareOrderTaskDetailEntity();
        taskDetail.setId(taskDetailId);
        taskDetail.setLockStatus(WareOrderTaskConstant.LockStatusEnum.UNLOCKED.getCode());
        orderTaskDetailService.updateById(taskDetail);
    }
}
```

##### bug_ware远程调用订单被登录拦截

```java
// ware远程调用订单，请求头没有登录消息被拦截，应该放行

/**
 * 登录拦截器
 * 从session中获取了登录信息（redis中），封装到了ThreadLocal中
 *
 * @Author: wanzenghui
 * @Date: 2021/12/20 22:29
 */
@Component
public class LoginUserInterceptor implements HandlerInterceptor {

    public static ThreadLocal<MemberResponseVO> loginUser = new ThreadLocal<>();

    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        // 放行无需登录的请求
        String uri = request.getRequestURI();
        AntPathMatcher antPathMatcher = new AntPathMatcher();// 匹配器
        boolean match = antPathMatcher.match("/order/order/status/**", uri);// 查询订单消息
        boolean match1 = antPathMatcher.match("/payed/notify", uri);// 支付回调
        if (match || match1) {
            return true;
        }

        // 获取登录用户信息
        MemberResponseVO attribute = (MemberResponseVO) request.getSession().getAttribute(AuthConstant.LOGIN_USER);
        if (attribute != null) {
            // 已登录，放行
            // 封装用户信息到threadLocal
            loginUser.set(attribute);
            return true;
        } else {
            // 未登录，跳转登录页面
            response.setContentType("text/html;charset=UTF-8");
            PrintWriter out = response.getWriter();
            out.println("<script>alert('请先进行登录，再进行后续操作！');location.href='http://auth.gulimall.com/login.html'</script>");
            // session.setAttribute("msg", "请先进行登录");
            // response.sendRedirect("http://auth.gulimall.com/login.html");
            return false;
        }
    }
}
```

### 7.3.消息丢失、消息重复、消息积压

* 消息丢失:

  * 情况1：网络连接失败，消息未抵达Broker
  * 解决：发送消息时同时将消息持久化到MQ中并插入DB（DB消息状态为已抵达）
             当出现异常时在catch处修改消息状态为错误抵达
  * 情况2：消息抵达Broker，但为抵达queue，消息会丢失（只有抵达了queue消息才会持久化）
  * 解决：开启生产者确认机制，将触发returnCallback.returnedMessage的消息DB状态修改为错误抵达
  * 情况3：消费者未ack时宕机，导致消息丢失
  * 解决：开启消费者手动ack
---
* 消息重复
  * 情况1：业务逻辑已经执行，但是ack时宕机，消息由unack变为ready，消息重新入队
  * 解决：将接口设计成幂等性，例如库存解锁时判断工作单的状态，已解锁则无操作
  * 解决2：防重表
---
* 消息积压
  * 情况1：生产者流量太大
  * 解决：减慢发送消息速率（验证码、防刷、重定向、削峰）
  
  * 情况2：消费者能力不足或宕机
  * 解决：上线更多消费者
  * 解决2：上线专门的队列消费服务，批量取出消息入库，离线处理业务慢慢处理

```java
1.网络宕机修改mq_message消息状态
/**
 * 关闭订单
 */
@Override
public void closeOrder(OrderEntity order) {
    OrderEntity _order = getById(order.getId());
    if (OrderConstant.OrderStatusEnum.CREATE_NEW.getCode().equals(_order.getStatus())) {
        // 代付款状态允许关单
        OrderEntity temp = new OrderEntity();
        temp.setId(order.getId());
        temp.setStatus(OrderConstant.OrderStatusEnum.CANCLED.getCode());
        updateById(temp);

        try {
            // 发送消息给MQ
            OrderTO orderTO = new OrderTO();
            BeanUtils.copyProperties(_order, orderTO);
            //TODO 持久化消息到mq_message表中，并设置消息状态为3-已抵达（保存日志记录）
            rabbitTemplate.convertAndSend("order-event-exchange", "order.release.other", orderTO);
        } catch (Exception e) {
            // TODO 消息为抵达Broker，修改mq_message消息状态为2-错误抵达
        }
    }
}

2.消息未抵达queue时修改mq_message消息状态
@Configuration
public class MyRabbitConfig {
    /**
     * 定制RabbitTemplate
     * 1、服务收到消息就会回调
     * 1、spring.rabbitmq.publisher-confirms: true
     * 2、设置确认回调
     * 2、消息正确抵达队列就会进行回调
     * 1、spring.rabbitmq.publisher-returns: true
     * spring.rabbitmq.template.mandatory: true
     * 2、设置确认回调ReturnCallback
     * <p>
     * 3、消费端确认(保证每个消息都被正确消费，此时才可以broker删除这个消息)
     */
    @PostConstruct   // (MyRabbitConfig对象创建完成以后，执行这个方法)
    public void initRabbitTemplate() {
        /**
         * 消息未到达队列触发returnCallback回调
         * 只要消息没有投递给指定的队列，就触发这个失败回调
         * @param message：投递失败的消息详细信息
         * @param replyCode：回复的状态码
         * @param replyText：回复的文本内容
         * @param exchange：接收消息的交换机
         * @param routingKey：接收消息的路由键
         */
        rabbitTemplate.setReturnCallback((message, replyCode, replyText, exchange, routingKey) -> {
            System.out.println("消息未到达队列触发returnCallback回调" +
                    "\nmessage ===> " + message +
                    "\nreplyCode ===> " + replyCode +
                    "\nreplyText ===> " + replyText +
                    "\nexchange ===> " + exchange +
                    "\nroutingKey ===> " + routingKey);
            // TODO 修改mq_message，设置消息状态为2-错误抵达【后期定时器重发消息】
        });
    }
}

3.开启消费者手动确认，详见之前属性配置处
    
4.将消费者接口设计成幂等性防止重复消费
```

#### 优化方案

```json
可以添加一个消息服务，各模块调用发送消息API即可
实现消息存库+异常修改状态

思考：如果feign调用失败不会出现问题，做好本地事务（feign失败即回滚）+接口幂等性即可
```

## 8.支付

```json
参考
	支付.md
```

### 8.1.member模块

```
支付成功回调地址member模块，所以这里要作member的相关配置

1.上传静态资源（订单列表页，用于支付成功同步回调）
将订单页 文件夹下静态资源拷贝到=>/mydata/nginx/html/static/member
将orderList.html拷贝到member模块下

2.member模块增加登录拦截器				LoginUserInterceptor
  增加拦截器配置类，将登录拦截器注册进去	  WebMvcConfigurer
  
3.网关配置转发
        - id: gulimall_member_route
          uri: lb://gulimall-member
          predicates:
            - Host=member.gulimall.com

4.增加本地host映射
# gulimall
192.168.56.10 gulimall.com
192.168.56.10 search.gulimall.com
192.168.56.10 item.gulimall.com
192.168.56.10 auth.gulimall.com
192.168.56.10 cart.gulimall.com
192.168.56.10 order.gulimall.com
192.168.56.10 member.gulimall.com

5.Feign请求头丢失问题
	订单支付成功回调：http://member.gulimall.com/memberOrder.html
	此时浏览器访问时member是带了cookie的，但远程请求order查询订单数据时，请求头丢失
	添加feign请求拦截器，封装请求头：GuliFeignConfig
```

![1641312832380](/assert/1641312832380.png)

#### 8.1.1.同步回调

```json
不建议在同步回调直接修改订单状态，推荐在异步回调的时候修改订单状态
```

#### 8.1.2.异步回调

![1641356753641](/assert/1641356753641.png)

```json
1.推荐在异步回调时修改订单状态
2.修改订单状态前要验签sign

程序执行完后必须打印输出“success”（不包含引号）。如果商户反馈给支付宝的字符不是 success 这7个字符，支付宝服务器会不断重发通知，直到超过 24 小时 22 分钟。一般情况下，25 小时以内完成 8 次通知（通知的间隔频率一般是：4m,10m,10m,1h,2h,6h,15h）。
```

### 8.2.内网穿透联调BUG

![1641357236422](/assert/1641357236422.png)

#### 8.2.1.内网穿透

```json
参考nps、npc相关文档搭建内网穿透
```

* bug1：使用nps作内网穿透，无法使用域名必须使用IP:PORT，所以会造成nginx无法根据访问的域名gulimall.com来匹配请求
  * 解决：
    * 方案一：修改nginx配置文件gulimall.conf监听server_name 124.223.7.41

---

* bug2：添加以上域名监听后，访问124.223.7.41:8888出现404异常
  * 原因：网关88未拦截到请求
  * 解决：
    * 方案一：在网关增加拦截规则，拦截124.223.7.41，将请求发送到order.gulimall.com
    * 方案二：在nginx转发时，设置host=order.gulimall.com，使网关可以正确拦截【推荐】
    * 方案三：内网穿透的地址直接配成192.168.56.1:9000【缺点：没有负载均衡了】

```json
bug1：
	修改gulimall.conf
server {
    listen       80;
    server_name gulimall.com *.gulimall.com 124.223.7.41;

    location /static/ {
        root /usr/share/nginx/html;
    }

    location / {
        proxy_set_header Host $host;
        proxy_pass http://gulimall;
    }

    error_page   500 502 503 504  /50x.html;
    location = /50x.html {
        root   /usr/share/nginx/html;
    }
}

bug2：
方案一：
        - id: gulimall_order_route2
          uri: lb://gulimall-order
          predicates:
            - Host=124.223.7.41

方案二：
	修改gulimall.conf
server {
    listen       80;
    server_name gulimall.com *.gulimall.com 124.223.7.41;

    location /static/ {
        root /usr/share/nginx/html;
    }

    location /payed/ {
        proxy_set_header Host order.gulimall.com;
        proxy_pass http://gulimall;
    }

    location / {
        proxy_set_header Host $host;
        proxy_pass http://gulimall;
    }

    error_page   500 502 503 504  /50x.html;
    location = /50x.html {
        root   /usr/share/nginx/html;
    }
}
```

![1641305201167](/assert/1641305201167.png)

**<u>内网穿透配置：</u>**

![1641364242705](/assert/1641364242705.png)
```
查看nginx异常命令

cd  /mydata/nginx/logs
cat error.log|grep 'payed'
```

## 9.收单

![1641388128847](/assert/1641388128847.png)

```json
1.订单超时，不允许支付
	解决：支付时设置超时时间：应该设置订单绝对超时时间，而不是30m，按照创建订单+30m来算截止时间
	time_expire
	
2.订单解锁完成，异步通知才到
	解决：释放库存的时候，手动调用收单功能（参照官方demo的实现）
```

# 九、秒杀模块

![1641390285576](/assert/1641390285576.png)

## 1.后台接口

### 1.1.【新增】秒杀场次

![1641391066477](/assert/1641391066477.png)

```sql
CREATE TABLE `sms_seckill_session` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT 'id',
  `name` varchar(200) DEFAULT NULL COMMENT '场次名称',
  `start_time` datetime DEFAULT NULL COMMENT '每日开始时间',
  `end_time` datetime DEFAULT NULL COMMENT '每日结束时间',
  `status` tinyint(1) DEFAULT NULL COMMENT '启用状态',
  `create_time` datetime DEFAULT NULL COMMENT '创建时间',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4 COMMENT='秒杀活动场次';
```

```java
@RestController
@RequestMapping("coupon/seckillsession")
public class SeckillSessionController {
    
    @Autowired
    private SeckillSessionService seckillSessionService;
    
    /**
     * 保存
     */
    @RequestMapping("/save")
    public R save(@RequestBody SeckillSessionEntity seckillSession){
		seckillSessionService.save(seckillSession);

        return R.ok();
    }
}
```

### 1.2.【查询】指定场次关联的商品列表

```
http://localhost:88/api/coupon/seckillskurelation/list?t=1641391939514&page=1&limit=10&key=&promotionSessionId=1
```

```java
@Service("seckillSkuRelationService")
public class SeckillSkuRelationServiceImpl extends ServiceImpl<SeckillSkuRelationDao, SeckillSkuRelationEntity> implements SeckillSkuRelationService {

    @Override
    public PageUtils queryPage(Map<String, Object> params) {
        QueryWrapper<SeckillSkuRelationEntity> wrapper = new QueryWrapper<>();
        String promotionSessionId = (String) params.get("promotionSessionId");
        if (StringUtils.isNotBlank(promotionSessionId)) {
            wrapper.eq("promotion_session_id", promotionSessionId);
        }
        IPage<SeckillSkuRelationEntity> page = this.page(
                new Query<SeckillSkuRelationEntity>().getPage(params),
                wrapper
        );

        return new PageUtils(page);
    }
}
```

### 1.3.【新增】秒杀场次关联商品

```sql
CREATE TABLE `sms_seckill_sku_relation` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT 'id',
  `promotion_id` bigint(20) DEFAULT NULL COMMENT '活动id',
  `promotion_session_id` bigint(20) DEFAULT NULL COMMENT '活动场次id',
  `sku_id` bigint(20) DEFAULT NULL COMMENT '商品id',
  `seckill_price` decimal(10,4) DEFAULT NULL COMMENT '秒杀价格',
  `seckill_count` int(11) DEFAULT NULL COMMENT '秒杀总量',
  `seckill_limit` int(11) DEFAULT NULL COMMENT '每人限购数量',
  `seckill_sort` int(11) DEFAULT NULL COMMENT '排序',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='秒杀活动商品关联';
```

```java
/**
 * 秒杀活动商品关联
 *
 * @author wanzenghui
 * @email lemon_wan@aliyun.com
 * @date 2021-09-02 22:43:18
 */
@RestController
@RequestMapping("coupon/seckillskurelation")
public class SeckillSkuRelationController {
    @Autowired
    private SeckillSkuRelationService seckillSkuRelationService;

    /**
     * 保存
     */
    @RequestMapping("/save")
    public R save(@RequestBody SeckillSkuRelationEntity seckillSkuRelation){
		seckillSkuRelationService.save(seckillSkuRelation);

        return R.ok();
    }
}
```

## 2.新增秒杀模块

![1641393092374](/assert/1641393092374.png)

![1641393188401](/assert/1641393188401.png)

![1641393315525](/assert/1641393315525.png)

## 3.【定时上架】秒杀场次+商品 

![1641447477743](/assert/1641447477743.png)

```json
1.提前将要秒杀的商品上架到redis中（减少db压力）
	从redis获取秒杀商品
	实现：
		使用定时任务，扫描第二天要秒杀的商品上架到redis中
		
2.秒杀商品的库存也上传到redis
	从redis扣除库存（信号量的方式）
```

```java
/**
 * 定时任务
 * @Description:
 * @Created: with IntelliJ IDEA.
 * @author: wanzenghui
 * @createTime: 2020-07-09 19:22
 */
@Slf4j
@Service
public class SeckillScheduled {

    @Autowired
    SeckillService seckillService;
    @Autowired
    RedissonClient redissonClient;

    /**
     * 秒杀商品定时上架，保证幂等性问题
     *  每天晚上3点，上架最近三天需要秒杀的商品
     *  当天00:00:00 - 23:59:59
     *  明天00:00:00 - 23:59:59
     *  后天00:00:00 - 23:59:59
     */
    @Scheduled(cron = "*/10 * * * * ? ")
    //@Scheduled(cron = "0 0 3 * * ? ")
    public void uploadSeckillSkuLatest3Days() {
        // 重复上架无需处理
        log.info("上架秒杀的商品...");

        // 分布式锁（幂等性）
        RLock lock = redissonClient.getLock(SeckillConstant.UPLOAD_LOCK);
        try {
            lock.lock(10, TimeUnit.SECONDS);
            // 上架最近三天需要秒杀的商品
            seckillService.uploadSeckillSkuLatest3Days();
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }
}
```

```java
@Slf4j
@Service
public class SeckillServiceImpl implements SeckillService {

    @Autowired
    CouponFeignService couponFeignService;
    @Autowired
    ProductFeignService productFeignService;
    @Autowired
    StringRedisTemplate redisTemplate;
    @Autowired
    RabbitTemplate rabbitTemplate;
    @Autowired
    RedissonClient redissonClient;

    /**
     * 上架最近三天需要秒杀的商品
     */
    @Override
    public void uploadSeckillSkuLatest3Days() {
        // 1.查询最近三天需要参加秒杀的场次+商品
        R lates3DaySession = couponFeignService.getLates3DaySession();
        if (lates3DaySession.getCode() == 0) {
            // 获取场次
            List<SeckillSessionWithSkusTO> sessions = lates3DaySession.getData("data", new TypeReference<List<SeckillSessionWithSkusTO>>() {
            });
            // 2.上架场次信息
            saveSessionInfos(sessions);
            // 3.上架商品信息
            saveSessionSkuInfo(sessions);
        }

    }

    /**
     * 上架场次
     */
    private void saveSessionInfos(List<SeckillSessionWithSkusTO> sessions) {
        if (!CollectionUtils.isEmpty(sessions)) {
            sessions.stream().forEach(session -> {
                // 1.遍历场次
                long startTime = session.getStartTime().getTime();// 场次开始时间戳
                long endTime = session.getEndTime().getTime();// 场次结束时间戳
                String key = SeckillConstant.SESSION_CACHE_PREFIX + startTime + "_" + endTime;// 场次的key

                // 2.判断场次是否已上架（幂等性）
                Boolean hasKey = redisTemplate.hasKey(key);
                if (!hasKey) {
                    // 未上架
                    // 3.封装场次信息
                    List<String> skuIds = session.getRelationSkus().stream()
                            .map(item -> item.getPromotionSessionId() + "_" + item.getSkuId().toString())
                            .collect(Collectors.toList());// skuId集合
                    // 4.上架
                    redisTemplate.opsForList().leftPushAll(key, skuIds);
                }
            });
        }
    }

    /**
     * 上架商品信息
     */
    private void saveSessionSkuInfo(List<SeckillSessionWithSkusTO> sessions) {
        if (!CollectionUtils.isEmpty(sessions)) {
            // 查询所有商品信息
            List<Long> skuIds = new ArrayList<>();
            sessions.stream().forEach(session -> {
                List<Long> ids = session.getRelationSkus().stream().map(SeckillSkuVO::getSkuId).collect(Collectors.toList());
                skuIds.addAll(ids);
            });
            R info = productFeignService.getSkuInfos(skuIds);
            if (info.getCode() == 0) {
                // 将查询结果封装成Map集合
                Map<Long, SkuInfoTO> skuMap = info.getData(new TypeReference<List<SkuInfoTO>>() {
                }).stream().collect(Collectors.toMap(SkuInfoTO::getSkuId, val -> val));
                // 绑定秒杀商品hash
                BoundHashOperations<String, Object, Object> operations = redisTemplate.boundHashOps(SeckillConstant.SECKILL_CHARE_KEY);
                // 1.遍历场次
                sessions.stream().forEach(session -> {
                    // 2.遍历商品
                    session.getRelationSkus().stream().forEach(seckillSku -> {
                        // 判断商品是否已上架（幂等性）
                        String skuKey = seckillSku.getPromotionSessionId().toString() + "_" + seckillSku.getSkuId().toString();// 商品的key（需要添加场次ID前缀，同一款商品可能场次不同）
                        if (!operations.hasKey(skuKey)) {
                            // 未上架
                            // 3.封装商品信息
                            SeckillSkuRedisTO redisTo = new SeckillSkuRedisTO();// 存储到redis的对象
                            SkuInfoTO sku = skuMap.get(seckillSku.getSkuId());
                            BeanUtils.copyProperties(seckillSku, redisTo);// 商品秒杀信息
                            redisTo.setSkuInfo(sku);// 商品详细信息
                            redisTo.setStartTime(session.getStartTime().getTime());// 秒杀开始时间
                            redisTo.setEndTime(session.getEndTime().getTime());// 秒杀结束时间
                            // 商品随机码：用户参与秒杀时，请求需要带上随机码（防止恶意攻击）
                            String token = UUID.randomUUID().toString().replace("-", "");// 商品随机码（随机码只会在秒杀开始时暴露）
                            redisTo.setRandomCode(token);// 设置商品随机码

                            // 4.上架商品（序列化成json格式存入Redis中）
                            String jsonString = JSONObject.toJSONString(redisTo);
                            operations.put(skuKey, jsonString);

                            // 5.上架商品的分布式信号量，key：商品随机码 值：库存（限流）
                            RSemaphore semaphore = redissonClient.getSemaphore(SeckillConstant.SKU_STOCK_SEMAPHORE + token);
                            // 信号量（扣减成功才进行后续操作，否则快速返回）
                            semaphore.trySetPermits(seckillSku.getSeckillCount());
                        }
                    });
                });
            }
        }
    }
}
```



## 4.【查询】当前可参与的秒杀商品列表

![1641447682882](/assert/1641447682882.png)

```java
@Slf4j
@Service
public class SeckillServiceImpl implements SeckillService {

    @Autowired
    CouponFeignService couponFeignService;
    @Autowired
    ProductFeignService productFeignService;
    @Autowired
    StringRedisTemplate redisTemplate;
    @Autowired
    RabbitTemplate rabbitTemplate;
    @Autowired
    RedissonClient redissonClient;
    
    /**
     * 获取到当前可以参加秒杀商品的信息
     */
    //@SentinelResource(value = "getCurrentSeckillSkusResource", blockHandler = "blockHandler")
    @Override
    public List<SeckillSkuRedisTO> getCurrentSeckillSkus() {
        //try (Entry entry = SphU.entry("seckillSkus")) {
        // 1.查询当前时间所属的秒杀场次
        long currentTime = System.currentTimeMillis();// 当前时间
        // 查询所有秒杀场次的key
        Set<String> keys = redisTemplate.keys(SeckillConstant.SESSION_CACHE_PREFIX + "*");// keys seckill:sessions:*
        for (String key : keys) {
            //seckill:sessions:1594396764000_1594453242000
            String replace = key.replace(SeckillConstant.SESSION_CACHE_PREFIX, "");// 截取时间，去掉前缀
            String[] time = replace.split("_");
            long startTime = Long.parseLong(time[0]);// 开始时间
            long endTime = Long.parseLong(time[1]);// 截止时间
            // 判断是否处于该场次
            if (currentTime >= startTime && currentTime <= endTime) {
                // 2.查询当前场次信息（查询结果List< sessionId_skuId > ）
                List<String> sessionIdSkuIds = redisTemplate.opsForList().range(key, -100, 100);// 获取list范围内100条数据
                // 获取商品信息
                BoundHashOperations<String, String, String> skuOps = redisTemplate.boundHashOps(SECKILL_CHARE_KEY);
                assert sessionIdSkuIds != null;
                // 根据List< sessionId_skuId >从Map中批量获取商品信息
                List<String> skus = skuOps.multiGet(sessionIdSkuIds);
                if (!CollectionUtils.isEmpty(skus)) {
                    // 将商品信息反序列成对象
                    List<SeckillSkuRedisTO> skuInfos = skus.stream().map(sku -> {
                        SeckillSkuRedisTO skuInfo = JSON.parseObject(sku.toString(), SeckillSkuRedisTO.class);
                        // redisTo.setRandomCode(null);当前秒杀开始需要随机码
                        return skuInfo;
                    }).collect(Collectors.toList());
                    return skuInfos;
                }
                // 3.匹配场次成功，退出循环
                break;
            }
        }
        //} catch (BlockException e) {
        //    log.error("资源被限流{}", e.getMessage());
        //}
        return null;
    }
}
```

## 5.【查询】商品详情页展示秒杀信息

![1641455421311](/assert/1641455421311.png)

```java
// product模块获取商品详情的时候，同时查询该商品的秒杀信息

@Slf4j
@Service
public class SeckillServiceImpl implements SeckillService {

    @Autowired
    CouponFeignService couponFeignService;
    @Autowired
    ProductFeignService productFeignService;
    @Autowired
    StringRedisTemplate redisTemplate;
    @Autowired
    RabbitTemplate rabbitTemplate;
    @Autowired
    RedissonClient redissonClient;

    /**
     * 根据skuId查询商品当前时间秒杀信息
     *
     * @param skuId
     */
    @Override
    public SeckillSkuRedisTO getSkuSeckilInfo(Long skuId) {
        // 1.匹配查询当前商品的秒杀信息
        BoundHashOperations<String, String, String> skuOps = redisTemplate.boundHashOps(SECKILL_CHARE_KEY);
        // 获取所有商品的key：sessionId_
        Set<String> keys = skuOps.keys();
        if (!CollectionUtils.isEmpty(keys)) {
            String lastIndex = "_" + skuId;
            for (String key : keys) {
                if (key.lastIndexOf(lastIndex) > -1) {
                    // 商品id匹配成功
                    String jsonString = skuOps.get(key);
                    // 进行序列化
                    SeckillSkuRedisTO skuInfo = JSON.parseObject(jsonString, SeckillSkuRedisTO.class);
                    Long currentTime = System.currentTimeMillis();
                    Long endTime = skuInfo.getEndTime();
                    if (currentTime <= endTime) {
                        // 当前时间小于截止时间
                        Long startTime = skuInfo.getStartTime();
                        if (currentTime >= startTime) {
                            // 返回当前正处于秒杀的商品信息
                            return skuInfo;
                        }
                        // 返回预告信息，不返回随机码
                        skuInfo.setRandomCode(null);// 随机码
                        return skuInfo;
                    }
                }
            }
        }
        return null;
    }
}
```

## 6.秒杀抢购

### 6.1.高并发需关注的问题

![1641453900687](/assert/1641453900687.png)

![1641454296255](/assert/1641454296255.png)



* 1.单一职责
* 2.秒杀链接加密
  * 随机码，秒杀开始才暴露
* 3.库存预热+快速扣减（redis存储库存信号量，最终正常进入购物车的流量最多是库存数）
  * 按照库存信号量原子扣减
* 4.动静分离
  * nginx/CDN
* 5.恶意请求拦截
  * 网关层按照访问次数拦截脚本请求【异常请求】
* 6.流量错峰
  * 【最重要是体现在秒杀开始的那一刻的错峰】判断登录状态、输入验证码、加入购物车、提交订单
* 7.限流&熔断&降级
  * 前端限流：间隔1秒允许点击
  * 后端限流：
    * 限制次数：同一个用户10次放行2次
    * 限制总量：秒杀服务峰值处理能力10万，网关层放行不得超过10万，超过的等待两秒放行
  * 熔断：A->B->C，链路中B总是失败，则下次调用时直接返回错误不调用B
  * 降级：流量太大，秒杀模块将流量引导到降级页面，服务繁忙页【正常请求】
* 8.队列削峰（杀手锏）
  * 扣减库存信号量成功的秒杀信息存入队列，订单系统监听队列创建订单（按照自己的处理能力消费）

### 6.2.【秒杀】队列削峰

```json
两种方案：
	方案一：
		加入购物车（仍然走购物车流程，但价格按照秒杀价格计算），创建订单、锁定库存
		优点：只需要做好适配，无大改动
		缺点：将秒杀的流量带给了其他模块
	方案二：【采用方案二，队列削峰】
		直接发送MQ消息，订单根据消息创建订单（不需要锁定库存，库存预热了【信号量】），订单关闭增加信号量
		优点：没有将秒杀的压力分担给其他模块，只有校验合法性没有远程调用、db操作
		缺点：订单等模块需要提供监听消费信息创建订单，如果订单崩了，会导致支付失败
		
假设一个请求50ms，一个线程1s能处理20个请求
Tomcat开启500个线程，1s能处理10000个请求
```

**<u>方案1：</u>**

<img src="/1641479321845.png" alt="1641479321845" style="zoom:80%;" />

<img src="/1641479379293.png" alt="1641479379293" style="zoom:80%;" />

**<u>方案2：</u>**

![1641461711787](/assert/1641461711787.png)

```java
/**
 * @Description:
 * @Created: with IntelliJ IDEA.
 * @author: wanzenghui
 * @createTime: 2020-07-09 19:29
 **/

@Slf4j
@Service
public class SeckillServiceImpl implements SeckillService {

    @Autowired
    StringRedisTemplate redisTemplate;
    @Autowired
    RabbitTemplate rabbitTemplate;
    @Autowired
    RedissonClient redissonClient;

    /**
     * 秒杀商品
     * 1.校验登录状态
     * 2.校验秒杀时间
     * 3.校验随机码、场次、商品对应关系
     * 4.校验信号量扣减，校验购物数量是否限购
     * 5.校验是否重复秒杀（幂等性）【秒杀成功SETNX占位  userId_sessionId_skuId】
     * 6.扣减信号量
     * 7.发送消息，创建订单号和订单信息
     * 8.订单模块消费消息，生成订单
     * @param killId    sessionId_skuid
     * @param key   随机码
     * @param num   商品件数
     */
    @Override
    public String kill(String killId, String key, Integer num) throws InterruptedException {
        // TODO 1.拦截器校验登录状态
        long start = System.currentTimeMillis();
        // 获取当前用户信息
        MemberResponseVO user = LoginUserInterceptor.loginUser.get();

        // 获取当前秒杀商品的详细信息
        BoundHashOperations<String, String, String> skuOps = redisTemplate.boundHashOps(SECKILL_CHARE_KEY);
        String jsonString = skuOps.get(killId);// 根据sessionId_skuid获取秒杀商品信息
        if (StringUtils.isEmpty(jsonString)) {
            // 这一步已经默认校验了场次+商品，如果为空表示校验失败
            return null;
        }
        // json反序列化商品信息
        SeckillSkuRedisTO skuInfo = JSON.parseObject(jsonString, SeckillSkuRedisTO.class);
        Long startTime = skuInfo.getStartTime();
        Long endTime = skuInfo.getEndTime();
        long currentTime = System.currentTimeMillis();
        // TODO 2.校验秒杀时间
        if (currentTime >= startTime && currentTime <= endTime) {
            // TODO 3.校验随机码
            String randomCode = skuInfo.getRandomCode();// 随机码
            if (randomCode.equals(key)) {
                // 获取每人限购数量
                Integer seckillLimit = skuInfo.getSeckillLimit();
                // 获取信号量
                String seckillCount = redisTemplate.opsForValue().get(SeckillConstant.SKU_STOCK_SEMAPHORE + randomCode);
                Integer count = Integer.valueOf(seckillCount);
                // TODO 4.校验信号量（库存是否充足）、校验购物数量是否限购
                if (num > 0 && num <= seckillLimit && count > num) {
                    // TODO 5.校验是否重复秒杀（幂等性）【秒杀成功后占位，userId-sessionId-skuId】
                    // SETNX 原子性处理
                    String userKey = SeckillConstant.SECKILL_USER_PREFIX + user.getId() + "_" + killId;
                    // 自动过期时间(活动结束时间 - 当前时间)
                    Long ttl = endTime - currentTime;
                    Boolean isRepeat = redisTemplate.opsForValue().setIfAbsent(userKey, num.toString(), ttl, TimeUnit.MILLISECONDS);
                    if (isRepeat) {
                        // 占位成功
                        // TODO 6.扣减信号量
                        RSemaphore semaphore = redissonClient.getSemaphore(SeckillConstant.SKU_STOCK_SEMAPHORE + randomCode);
                        boolean isAcquire = semaphore.tryAcquire(num, 100, TimeUnit.MILLISECONDS);
                        if (isAcquire) {
                            // 信号量扣减成功，秒杀成功，快速下单
                            // TODO 7.发送消息，创建订单号和订单信息
                            // 秒杀成功 快速下单 发送消息到 MQ 整个操作时间在 10ms 左右
                            String orderSn = IdWorker.getTimeId();// 订单号
                            SeckillOrderTO order = new SeckillOrderTO();// 订单
                            order.setOrderSn(orderSn);// 订单号
                            order.setMemberId(user.getId());// 用户ID
                            order.setNum(num);// 商品上来给你
                            order.setPromotionSessionId(skuInfo.getPromotionSessionId());// 场次id
                            order.setSkuId(skuInfo.getSkuId());// 商品id
                            order.setSeckillPrice(skuInfo.getSeckillPrice());// 秒杀价格
                            // TODO 需要保证可靠消息，发送者确认+消费者确认（本地事务的形式）
                            rabbitTemplate.convertAndSend("order-event-exchange", "order.seckill.order", order);
                            long end = System.currentTimeMillis();
                            log.info("秒杀成功，耗时..." + (end - start));
                            return orderSn;
                        }
                    }
                }
            }
        }
        long end = System.currentTimeMillis();
        log.info("秒杀失败，耗时..." + (end - start));
        return null;
    }
}
```

### 6.3.TODO释放信号量

```json
1.接收创建秒杀订单的队列也应该做成延时队列，超时未支付，消息进入死信队列释放订单
2.监听释放订单的消费者，释放订单后，发送一条释放信号量的信息到释放信号量的死信队列
3.监听释放信号量的死信队列，逻辑跟释放库存一样（释放订单产生一条释放库存的消息，延时队列产生一条释放库存的消息）
```

### 6.4.TODO释放库存

```json
场次超时后，将信号量归还到库存
```

# 十、熔断、限流、链路追踪

## 1.整合步骤

### 1.1.定义资源

```json
多种定义资源的方法
1.主流框架适配，例如适配feign后所有feign请求都是资源【限流、降级后，触发熔断fallback】
 			 spring所有controller请求都是资源【限流、降级后，触发UrlBlockSentinelHandler处理】
			 适配gateway后，所有routes都是资源【限流、降级后，触发UrlBlockSentinelHandler处理】

2.自定义资源，使用try{}catch{}【限流、降级后，在catch中处理】
3.注解定义资源，使用@SentinelResource(blockHandler = "blockHandlerForGetUser")【流、降级后，在blockHandlerForGetUser中处理】
```



### 1.2.定义规则

### 1.3.检验规则是否生效

## 2.整合sentinel

```json
参考 12.熔断+降级+限流+链路追踪（sentinel）.md
```



# 总结

## 后台请求和前台请求路由

```json
后台请求都添加了/api/member/xxx
 			 /api/coupon/xxx
 			 /api/renren-fast/xx

前台请求都没有/api

结论：
	1.gateway拦截后台请求的时候，要将/api/member/xx  请求拦截，然后将请求替换成/member/xx
	
	2.gateway拦截前台请求按照host拦截，不按照url拦截，
	例如order.gulimall.com
       member.gulimall.com
```

## 单元测试

```java
版本2.1.8：
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>

@RunWith(SpringRunner.class)// 使用spring驱动
@SpringBootTest
public class GulimallSearchApplicationTests {

    @Autowired
    private RestHighLevelClient client;

    @Test
    public void contextLoads() {
    }

    @Test
    void testEs() {
        System.out.println(client);
    }
}

版本2.3.2：
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
            <exclusions>
                <exclusion>
                    <groupId>org.junit.vintage</groupId>
                    <artifactId>junit-vintage-engine</artifactId>
                </exclusion>
            </exclusions>
        </dependency>
    
@SpringBootTest
class GulimallSearchApplicationTests {

    @Autowired
    private RestHighLevelClient client;

    @Test
    void testEs() {
        System.out.println(client);
    }
}
```

## 组件间调用R类型问题

```java
1.方法1：（无法实现，以为R继承自HashMap，data作为私有属性无法使用）
    设计返回类型R的时候加上泛型（feign调用时，springboot底层会根据泛型封装data类型）
public class R<T> extends HashMap<String, Object> {
    private T data;
    
    public T getDate() {
        return data;
    }
    
    public void setData(T data) {
        this.data = data;
    }
}

2.方法2：
    controller返回数据类型不使用R，直接使用List<SkuHasStockTO>

3.方法3：
public class R<T> extends HashMap<String, Object> {
	public R put(String key, Object value) {
		super.put(key, value);
		return this;
	}
    
	/**
	 * 封装数据
	 */
	public R setData(Object data) {
		return put("data", data);
	}

    /**
	 * 解析数据
	 * 1.@ResponseBody返回类型被封装成了Json格式
	 * 2.feign接收参数时也会封装成json格式，data对象也被解析成json格式的数据（[集合对象]或{map对象}）
	 * 3.将data转成json字符串格式，然后再解析成对象
	 */
	public <T> T getData(TypeReference<T> type) {
		Object data = get("data");
		String jsonString = JSONObject.toJSONStringWithDateFormat(data, DateConstant.DATE_FORMAT);
		return JSONObject.parseObject(jsonString, type);
	}
}
```

## feign调用源码

```java
/**
* 1、构造请求数据，将对象转为json
*      RequestTemplate template = buildTemplateFromArgs.create(argv);
* 2、发送请求进行执行：【执行成功会解码响应数据】
*      excuteAndDecode(template)
* 3、执行请求会有重试机制
*      while(true){
*          try{
*              excuteAndDecode(template)
*          }catch() {
*              try{
*                  // 默认重试5次【具体是否重试查看重试器的实现】
*                  retryer.continueOrPropagate(e);
*               }catch() {
*                  throw ex;
*               }
*              continue;
*          }
*      }
*
*
*/
```

## 查询结果使用包装类型

```properties
mapper查询返回使用Long代替long
	原因：查询结果为null时，无法为long封装null值
```

## RedirectAttributes

```
作用：
	重定向数据域
	1.attributes.addFlashAttribute("errors", errMap);// flash，session中的数据只使用一次
	2.attributes.addAttribute("skuId", skuId);// 会在url后面拼接参数
```

## 添加新模块步骤

```
1.网关转发配置
2.spring-session依赖
  spring-session配置
  spring-session注解（@EnableRedisHttpSession）
3.登录拦截 LoginUserInterceptor、WebMvcConfigurer
4.域名映射
5.添加feign拦截器：GuliFeignConfig
  构造请求头，避免cookie丢失登录拦截
6.添加mybatis拦截器：MybatisConfig
  分页查询时封装总记录数、总页码数
```

